<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Paragraph Adapter (Feedback)</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg:       #0b0b13;
  --surface:  #11111c;
  --surface2: #181828;
  --border:   #1e1e32;
  --border2:  #2a2a45;
  --muted:    #484868;
  --text:     #c4c4de;
  --accent:   #7c5cfc;
  --green:    #22c55e;
  --gold:     #d97706;
  --header-blue: #60a5fa;
  --core-ui-text-size: 13.7px;
}
[data-theme="light"] {
  --bg:       #f6f7fb;
  --surface:  #ffffff;
  --surface2: #eef1f8;
  --border:   #d9dfec;
  --border2:  #c6cee1;
  --muted:    #6c748c;
  --text:     #1c2233;
  --accent:   #5a67d8;
  --green:    #16a34a;
  --gold:     #b45309;
  --header-blue: #2563eb;
}
[data-theme="light"] .cadence-wrap {
  background:
    linear-gradient(
      90deg,
      rgba(217, 119, 6, 0.22) 0%,
      rgba(217, 119, 6, 0.22) var(--cad-progress, 0%),
      rgba(255, 255, 255, 0.92) var(--cad-progress, 0%),
      rgba(255, 255, 255, 0.92) 100%
    );
}
[data-theme="light"] .output-current {
  color: #111827;
}
[data-theme="light"] .output-current h1,
[data-theme="light"] .output-current h2,
[data-theme="light"] .output-current h3,
[data-theme="light"] .output-current strong {
  color: #0f172a;
}
[data-theme="light"] .output-current em {
  color: #334155;
}
[data-theme="light"] .combo-list {
  background: #ffffff;
  border-color: #c6cee1;
  box-shadow: 0 10px 24px rgba(15, 23, 42, 0.14);
}
[data-theme="light"] .combo-item {
  color: #1c2233;
}
[data-theme="light"] .combo-item:hover,
[data-theme="light"] .combo-item:focus {
  border-color: #5a67d8;
  background: rgba(90, 103, 216, 0.10);
}
[data-theme="light"] .deadzone-band {
  background: rgba(37, 99, 235, 0.06);
  border-left-color: rgba(37, 99, 235, 0.26);
  border-right-color: rgba(37, 99, 235, 0.26);
}
[data-theme="light"] .tag-token {
  background: rgba(90, 103, 216, 0.08);
  border-color: rgba(90, 103, 216, 0.28);
  color: #1f2a44;
}
[data-theme="light"] .tag-token-del {
  color: #2f3b5a;
  opacity: 0.72;
}

html, body {
  min-height: 100vh;
  height: 100dvh;
  overflow: hidden;
  background: var(--bg);
  color: var(--text);
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
}

/* ═══════════════════════════════
   PAGE LAYOUT — single column, full-width stacked
═══════════════════════════════ */
.page {
  min-height: 100vh;
  height: 100dvh;
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  overflow-x: hidden;
}
.page::-webkit-scrollbar { width: 5px; }
.page::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }

/* ═══════════════════════════════
   SHARED ROW STYLE
═══════════════════════════════ */
.row {
  padding: 16px 24px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.row-label {
  font-size: 10px;
  letter-spacing: 2.5px;
  text-transform: uppercase;
  color: var(--header-blue);
  font-weight: 600;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
}

#keep-brief,
#you-are-what-you-eat {
  accent-color: var(--header-blue);
}

/* ═══════════════════════════════
   INPUTS
═══════════════════════════════ */
textarea {
  width: 100%;
  background: var(--surface2);
  border: 1px solid var(--border2);
  border-radius: 8px;
  padding: 10px 14px;
  color: var(--text);
  font-family: inherit;
  resize: none;
  outline: none;
  line-height: 1.6;
}
textarea:focus { border-color: var(--accent); }

#mission,
#food-for-thought,
#direction-1,
#direction-2,
.output-current {
  font-size: var(--core-ui-text-size);
}

#direction-1,
#direction-2 {
  scrollbar-width: none;      /* Firefox */
  -ms-overflow-style: none;   /* IE/Edge legacy */
}
#direction-1::-webkit-scrollbar,
#direction-2::-webkit-scrollbar {
  width: 0;
  height: 0;
}

#row-source,
#row-food {
  min-height: 136px;
}

#mission,
#food-for-thought {
  height: 84px;
  min-height: 84px;
  max-height: 84px;
  overflow-y: auto;
}
.output-current.editing {
  border-color: #f59e0b;
  box-shadow: 0 0 0 1px rgba(245,158,11,0.35), 0 4px 24px rgba(0,0,0,0.4);
  cursor: text;
}

.sentence-row {
  display: flex;
  gap: 10px;
  align-items: stretch;
}

.trawl-row {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: nowrap;
}
.trawl-input {
  flex: 1 1 0;
  min-width: 0;
  font-size: 12px;
  font-family: inherit;
  color: var(--text);
  background: var(--surface2);
  border: 1px solid var(--border2);
  border-radius: 6px;
  padding: 6px 10px;
  height: 32px;
  line-height: 1.4;
}
.trawl-input::placeholder {
  color: var(--muted);
}


/* ── Tag input (concepts) ─────────────────────── */
.tag-input-wrap {
  flex: 1;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 5px;
  background: var(--surface2);
  border: 1px solid var(--border2);
  border-radius: 8px;
  padding: 5px 10px;
  min-height: 34px;
  cursor: text;
  transition: border-color 0.15s;
}
.tag-input-wrap:focus-within { border-color: var(--accent); }
.tag-token {
  display: inline-flex;
  align-items: center;
  background: rgba(124,92,252,0.18);
  border: 1px solid rgba(124,92,252,0.35);
  border-radius: 5px;
  padding: 1px 7px;
  font-size: 12px;
  font-weight: 600;
  color: #c4b5fd;
  white-space: nowrap;
  user-select: none;
  gap: 5px;
}
.tag-token-del {
  font-size: 10px;
  opacity: 0.5;
  cursor: pointer;
  line-height: 1;
  padding: 0 1px;
  transition: opacity 0.1s;
}
.tag-token-del:hover { opacity: 1; }
.tag-input-field {
  border: none;
  outline: none;
  background: transparent;
  color: var(--text);
  font-family: inherit;
  font-size: 12px;
  flex: 1;
  min-width: 80px;
  height: 22px;
  padding: 0;
}
/* Hidden real textarea keeps the actual value for form/JS reads */
#sentence-input { display: none; }

/* ═══════════════════════════════
   MIXER + SENSIBILITY BOXES BELOW
═══════════════════════════════ */
.mixer-section {
  padding: 16px 24px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.mixer-wrap {
  position: relative;
  height: 300px;
  overflow: hidden;
  border-radius: 10px;
  border: 1px solid var(--border2);
  background:
    linear-gradient(to bottom,
      rgba(244,114,182,0.08) 0%,
      rgba(190,24,93,0.04)  45%,
      rgba(109,40,217,0.03) 100%),
    var(--surface);
}
.ascii-bg-layer {
  position: absolute;
  inset: 0;
  z-index: 0;
  pointer-events: none;
  opacity: 0;
  transition: opacity 180ms ease;
}
.ascii-bg-layer.active {
  opacity: 0.26;
}
.ascii-bg-frame {
  width: 100%;
  height: 100%;
  border: 0;
  display: block;
  pointer-events: none;
  background: transparent;
}
[data-theme="light"] .ascii-bg-layer.active {
  opacity: 0.14;
}
[data-theme="light"] .ascii-bg-frame {
  filter: invert(1) hue-rotate(180deg) saturate(0.72) contrast(0.9) brightness(1.08);
}
.pong-canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  display: none;
  z-index: 30;
}
.fx-layer {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 26;
}
.shark-layer {
  position: absolute;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
  z-index: 27;
}
.shark-run {
  display: none;
  position: absolute;
  inset: 0;
}
.shark-run.active {
  display: block;
}
.black-hole {
  position: absolute;
  left: var(--bh-x, 50%);
  top: var(--bh-y, 56%);
  width: 0;
  height: 0;
  transform: translate(-50%, -50%);
  border-radius: 999px;
  box-shadow:
    0 0 0 0 rgba(96,165,250,0.14),
    0 0 0 0 rgba(147,197,253,0.10);
  animation: blackHoleLife 1000ms ease-in-out forwards;
}
.black-hole::before {
  content: '';
  position: absolute;
  left: 50%;
  top: 50%;
  width: 42px;
  height: 42px;
  transform: translate(-50%, -50%);
  border-radius: 999px;
  background:
    radial-gradient(circle at 30% 30%, rgba(30,58,138,0.25), rgba(2,6,23,0.95) 58%),
    radial-gradient(circle at 60% 60%, rgba(147,197,253,0.16), rgba(2,6,23,0) 72%);
  box-shadow:
    0 0 14px rgba(96,165,250,0.42),
    inset 0 0 10px rgba(0,0,0,0.85);
}
.vf-single {
  position: absolute;
  left: var(--bh-x, 50%);
  top: var(--bh-y, 56%);
  width: 72px;
  height: 34px;
  transform: translate(-50%, -50%);
  opacity: 0;
  filter: drop-shadow(0 0 8px rgba(147,197,253,0.62));
  animation: fishFromHole 1000ms cubic-bezier(0.22, 0.7, 0.2, 1) forwards;
}
.bh-spark {
  position: absolute;
  left: var(--bh-x, 50%);
  top: var(--bh-y, 56%);
  width: 3px;
  height: 3px;
  border-radius: 999px;
  background: rgba(191,219,254,0.95);
  box-shadow: 0 0 7px rgba(96,165,250,0.72);
  opacity: 0;
  transform: translate(-50%, -50%);
  animation: bhSparkBurst 260ms ease-out forwards;
  animation-delay: calc(720ms + (var(--i) * 10ms));
}
@keyframes blackHoleLife {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.25);
  }
  12% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  80% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.05);
  }
  90% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.34);
  }
  96% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(0.86);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.35);
  }
}
@keyframes fishFromHole {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) translate(0px, 0px) rotate(0deg) scale(0.15);
  }
  12% {
    opacity: 1;
    transform: translate(-50%, -50%) translate(10px, -6px) rotate(120deg) scale(1);
  }
  34% {
    opacity: 1;
    transform: translate(-50%, -50%) translate(108px, -52px) rotate(440deg) scale(1.02);
  }
  58% {
    opacity: 1;
    transform: translate(-50%, -50%) translate(156px, 24px) rotate(690deg) scale(0.98);
  }
  76% {
    opacity: 1;
    transform: translate(-50%, -50%) translate(56px, 40px) rotate(960deg) scale(0.96);
  }
  90% {
    opacity: 1;
    transform: translate(-50%, -50%) translate(-6px, -118px) rotate(1080deg) scale(0.92);
  }
  96% {
    opacity: 1;
    transform: translate(-50%, -50%) translate(-2px, -98px) rotate(1170deg) scale(1.34);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -50%) translate(0px, 0px) rotate(1170deg) scale(0.1);
  }
}
@keyframes bhSparkBurst {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) translate(0px, 0px) scale(0.7);
  }
  20% {
    opacity: 1;
  }
  100% {
    opacity: 0;
    transform:
      translate(-50%, -50%)
      translate(var(--dx, 0px), var(--dy, 0px))
      scale(0.18);
  }
}
.mixer-wrap.pong-mode .pong-canvas {
  display: block;
}
.mixer-wrap.pong-mode .guide,
.mixer-wrap.pong-mode .deadzone-band,
.mixer-wrap.pong-mode .axis-left,
.mixer-wrap.pong-mode .axis-right,
.mixer-wrap.pong-mode .axis-color-pick,
.mixer-wrap.pong-mode .ascii-bg-layer,
.mixer-wrap.pong-mode .fx-layer,
.mixer-wrap.pong-mode .shark-layer,
.mixer-wrap.pong-mode .mixer-empty,
.mixer-wrap.pong-mode .word-chip {
  display: none !important;
}
@keyframes mergeSparkBurst {
  0% {
    transform: translate(-50%, -50%) translate(0px, 0px) scale(1);
    opacity: 0;
  }
  14% {
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) translate(var(--dx), var(--dy)) scale(0.25);
    opacity: 0;
  }
}
.merge-spark {
  position: absolute;
  left: 0;
  top: 0;
  width: 3px;
  height: 3px;
  border-radius: 999px;
  background: rgba(147, 197, 253, 0.95);
  box-shadow: 0 0 6px rgba(96,165,250,0.75);
  animation: mergeSparkBurst 520ms ease-out forwards;
}

/* Deadzone overlay band in the center of the mixer */
.deadzone-band {
  position: absolute;
  top: 0; bottom: 0;
  /* width + left set via JS */
  background: rgba(255,255,255,0.025);
  border-left: 1px dashed rgba(255,255,255,0.08);
  border-right: 1px dashed rgba(255,255,255,0.08);
  pointer-events: none;
  z-index: 1;
}
.deadzone-label {
  position: absolute;
  bottom: 28px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 8px;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  color: rgba(255,255,255,0.18);
  white-space: nowrap;
  pointer-events: none;
}

/* Sensibility boxes sit below the mixer, left and right */
.sensibility-row {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  margin-top: 10px;
}
.mixer-resize-handle {
  display: none;
  margin-top: 18px;
  height: 14px;
  cursor: ns-resize;
  user-select: none;
  position: relative;
}
.mixer-resize-handle::before {
  content: '↕';
  position: absolute;
  left: 2px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 20px;
  color: var(--muted);
  line-height: 1;
  background: var(--bg);
  padding-right: 6px;
}
.mixer-resize-handle::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  border-top: 2px solid var(--border2);
}
@media (hover: hover) and (pointer: fine) {
  .mixer-section {
    border-bottom: none;
  }
  .mixer-resize-handle {
    display: block;
  }
}
.sensibility-box {
  width: 200px;
  flex-shrink: 1;
  display: flex;
  flex-direction: column;
  gap: 5px;
}
.sensibility-controls {
  width: auto;
  flex: 0 0 auto;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 0;
  background: none;
  border: none;
  white-space: nowrap;
}
.sensibility-box.right {
  text-align: right;
}
.sensibility-label {
  font-size: 9px;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  font-weight: 600;
}
.sensibility-box.left .sensibility-label {
  color: rgba(236,72,153,0.7); /* updated dynamically by renderChips */
}
.sensibility-box.right .sensibility-label {
  color: rgba(52,211,153,0.7); /* updated dynamically by renderChips */
}
.sensibility-box textarea,
.sensibility-box input {
  font-size: 12px;
  font-family: inherit;
  color: var(--text);
  background: var(--surface2);
  border: 1px solid var(--border2);
  border-radius: 6px;
  padding: 6px 10px;
  resize: none;
  height: 32px;
  line-height: 1.4;
}
.sensibility-box input::placeholder {
  color: var(--muted);
}
.sensibility-combo {
  position: relative;
  width: 100%;
}
.sensibility-combo input {
  width: 100%;
  padding-right: 46px;
}
.combo-arrow {
  position: absolute;
  right: 7px;
  top: 50%;
  transform: translateY(-50%);
  width: 24px;
  height: 24px;
  border: none;
  border-radius: 0;
  background: transparent;
  color: var(--muted);
  font-size: 11px;
  line-height: 1;
  cursor: pointer;
  padding: 0;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
.combo-arrow:hover {
  color: var(--text);
}
.combo-list {
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  right: 0;
  z-index: 60;
  display: none;
  max-height: 180px;
  overflow-y: auto;
  background: #121224;
  border: 1px solid var(--border2);
  border-radius: 8px;
  box-shadow: 0 10px 26px rgba(0,0,0,0.45);
  padding: 4px;
}
.combo-list.open {
  display: block;
}
.combo-item {
  width: 100%;
  text-align: left;
  border: 1px solid transparent;
  background: transparent;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  line-height: 1.3;
  border-radius: 6px;
  padding: 5px 7px;
  cursor: pointer;
}
.combo-item:hover,
.combo-item:focus {
  outline: none;
  border-color: var(--accent);
  background: rgba(124, 92, 252, 0.12);
}
.guide {
  position: absolute;
  left: 0; right: 0;
  height: 1px;
  background: var(--border);
  pointer-events: none;
}

.axis-left {
  position: absolute;
  left: 12px; top: 10px;
  font-size: 9px; letter-spacing: 1px; text-transform: uppercase;
  color: rgba(236,72,153,0.40);
  pointer-events: all;
  cursor: pointer;
  max-width: 35%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  z-index: 5;
  transition: color 0.15s, opacity 0.15s;
}
.axis-left:hover { opacity: 0.85; filter: brightness(1.4); }
.axis-right {
  position: absolute;
  right: 12px; top: 10px;
  font-size: 9px; letter-spacing: 1px; text-transform: uppercase;
  color: rgba(52,211,153,0.40);
  pointer-events: all;
  cursor: pointer;
  max-width: 35%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  text-align: right;
  z-index: 5;
  transition: color 0.15s, opacity 0.15s;
}
.axis-right:hover { opacity: 0.85; filter: brightness(1.4); }
/* Hidden colour pickers anchored in the mixer corners */
.axis-color-pick {
  position: absolute;
  top: 10px;
  opacity: 0;
  width: 0;
  height: 0;
  border: none;
  padding: 0;
  cursor: pointer;
  pointer-events: none;
}
#axis-pick-1 { left: 12px; }
#axis-pick-2 { right: 12px; }
.mixer-empty {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 8px;
  color: var(--muted);
  font-size: 12px;
  pointer-events: none;
}
.mixer-empty-icon { font-size: 24px; opacity: 0.35; }

/* Word chips */
.word-chip {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3px;
  cursor: grab;
  user-select: none;
  transform: translate(-50%, -50%);
  z-index: 10;
  width: 72px;
}
.word-chip:hover .chip-pill { filter: brightness(1.15); }
.word-chip.is-dragging { cursor: grabbing; z-index: 20; }
.word-chip.is-dragging .chip-pill { filter: brightness(1.3); box-shadow: 0 4px 24px rgba(0,0,0,0.6); }
.word-chip.selected .chip-pill {
  outline: 2px solid rgba(255,255,255,0.65);
  outline-offset: 2px;
}
.chip-pill {
  position: relative;
  border-radius: 8px;
  padding: 3px 6px;
  font-weight: 700;
  font-size: 9px;
  border: 1.5px solid;
  white-space: normal;
  word-break: break-word;
  text-align: center;
  width: 100%;
  transition: background 0.15s, color 0.15s, border-color 0.15s, transform 0.08s;
  box-shadow: 0 2px 10px rgba(0,0,0,0.35);
  line-height: 1.3;
  transform-origin: center center;
}
.chip-merge-progress {
  width: 100%;
  height: 4px;
  border-radius: 999px;
  overflow: hidden;
  border: 1px solid rgba(96,165,250,0.55);
  background: rgba(96,165,250,0.12);
  box-shadow: 0 0 8px rgba(96,165,250,0.35);
}
.chip-merge-progress-fill {
  height: 100%;
  width: var(--merge-pct, 0%);
  background: linear-gradient(90deg, #60a5fa, #93c5fd);
  box-shadow: 0 0 6px rgba(96,165,250,0.7);
  transition: width 0.04s linear;
}
.chip-weight {
  font-size: 8px;
  font-weight: 700;
  font-family: 'Courier New', monospace;
  letter-spacing: 0.5px;
  transition: color 0.15s;
}

/* ═══════════════════════════════
   PROMPT BLOCK
═══════════════════════════════ */
.prompt-block {
  background: #060d14;
  border: 1px solid #0e2030;
  border-radius: 8px;
  padding: 14px 18px;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  color: #3d8f5c;
  line-height: 1.8;
  white-space: pre-wrap;
  word-break: break-word;
  max-height: 200px;
  overflow-y: auto;
}
.prompt-block::-webkit-scrollbar { width: 3px; }
.prompt-block::-webkit-scrollbar-thumb { background: #0e2030; border-radius: 2px; }

/* ═══════════════════════════════
   CURRENT OUTPUT
═══════════════════════════════ */
.current-wrap {
  padding: 16px 24px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.live-badge {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 10px;
  letter-spacing: 2.5px;
  text-transform: uppercase;
  font-weight: 600;
  color: #60a5fa;
}
.live-dot {
  width: 7px; height: 7px;
  border-radius: 50%;
  background: #3b82f6;
  flex-shrink: 0;
}
/* Streaming state: flashing amber-red */
.live-dot.streaming {
  background: #f59e0b;
  animation: pulse-stream 0.8s ease-in-out infinite;
}
@keyframes pulse-stream {
  0%, 100% { opacity: 1; background: #f59e0b; }
  50%      { opacity: 0.3; background: #ef4444; }
}

.output-current {
  background: var(--surface);
  border: 1px solid var(--accent);
  border-radius: 10px;
  padding: 10px 14px;
  line-height: 1.6;
  color: var(--text);
  transition: opacity 0.2s;
  box-shadow: 0 0 0 1px rgba(124,92,252,0.15), 0 4px 24px rgba(0,0,0,0.4);
  height: 64px;
  max-height: 64px;
  overflow-y: auto;
}
.output-with-controls {
  margin-top: 10px;
  display: flex;
  align-items: flex-start;
  gap: 8px;
}
.output-with-controls .output-current {
  flex: 1 1 auto;
}
.output-size-controls {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  align-self: flex-start;
  gap: 6px;
  flex: 0 0 auto;
}
.output-size-btn {
  width: 44px;
  height: 36px;
  border-radius: 6px;
  border: 1px solid var(--border2);
  background: var(--surface2);
  color: var(--muted);
  font-size: 12px;
  font-weight: 700;
  cursor: pointer;
  line-height: 1;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
.output-size-btn:hover {
  border-color: var(--accent);
  color: var(--text);
}
.output-current::-webkit-scrollbar { width: 3px; }
.output-current::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }
/*.output-current.fading { opacity: 0.3; }*/

/* Markdown styling inside output */
.output-current h1,
.output-current h2,
.output-current h3 {
  color: #e0e0f0;
  margin: 0.6em 0 0.3em;
  line-height: 1.4;
}
.output-current h1 { font-size: 1.3em; }
.output-current h2 { font-size: 1.15em; }
.output-current h3 { font-size: 1.05em; }
.output-current strong { color: #e8e8f8; }
.output-current em { color: #b8b8d8; }
.output-current ul, .output-current ol {
  margin: 0.4em 0;
  padding-left: 1.5em;
}
.output-current li { margin: 0.2em 0; }
.output-current p { margin: 0 0 0.4em 0; }
.output-current > :first-child { margin-top: 0; }
.output-current > :last-child { margin-bottom: 0; }

/* ═══════════════════════════════
   HISTORY (compact list)
═══════════════════════════════ */
.history-empty {
  padding: 20px 0;
  font-size: 12px;
  color: var(--muted);
  text-align: center;
  line-height: 1.7;
}

.history-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 0;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background 0.15s;
  border-radius: 4px;
}
.history-item:hover {
  background: var(--surface2);
}
.history-item.active {
  background: rgba(124,92,252,0.08);
}
.history-num {
  font-size: 9px;
  color: var(--muted);
  font-variant-numeric: tabular-nums;
  flex-shrink: 0;
  width: 16px;
  text-align: right;
}
.history-preview {
  flex: 1;
  font-size: 12px;
  color: var(--text);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  min-width: 0;
}
.history-tags {
  display: flex;
  gap: 4px;
  flex-wrap: nowrap;
  flex-shrink: 0;
}
.snap-tag {
  font-size: 8px;
  font-family: 'Courier New', monospace;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--surface2);
  border: 1px solid var(--border2);
  color: var(--muted);
  white-space: nowrap;
}

/* ═══════════════════════════════
   BASE PROMPT EDITOR
═══════════════════════════════ */
.base-prompt-editor {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.base-prompt-editor label {
  font-size: 9px;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  color: var(--muted);
  font-weight: 600;
  margin-bottom: 4px;
  display: block;
}
.base-prompt-editor textarea {
  font-family: 'Courier New', monospace;
  font-size: 11px;
  color: #3d8f5c;
  background: #060d14;
  border-color: #0e2030;
  line-height: 1.7;
}
.base-prompt-editor textarea:focus { border-color: #1a5040; }

/* ═══════════════════════════════
   MODEL SELECTOR
═══════════════════════════════ */
.model-select {
  background: var(--surface2);
  border: 1px solid var(--border2);
  border-radius: 6px;
  color: var(--muted);
  font-family: inherit;
  font-size: 10px;
  letter-spacing: 0.5px;
  padding: 4px 8px;
  cursor: pointer;
  outline: none;
  transition: border-color 0.15s, color 0.15s;
}
.model-select.timing {
  background:
    linear-gradient(
      90deg,
      rgba(124, 92, 252, 0.30) 0%,
      rgba(124, 92, 252, 0.30) var(--req-progress, 0%),
      rgba(24, 24, 40, 0.96) var(--req-progress, 0%),
      rgba(24, 24, 40, 0.96) 100%
    );
  color: #e4e4f8;
}
.model-select.timing.overtime {
  animation: modelOvertimePulse 1.2s ease-in-out infinite;
}
.model-select:hover, .model-select:focus {
  border-color: var(--accent);
  color: var(--text);
}

@keyframes modelOvertimePulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(124, 92, 252, 0.16); }
  50%      { box-shadow: 0 0 0 2px rgba(124, 92, 252, 0.32); }
}

.feedback-btn {
  background: var(--surface2);
  border: 1px solid var(--border2);
  border-radius: 6px;
  color: var(--muted);
  font-family: inherit;
  font-size: 10px;
  letter-spacing: 0.6px;
  padding: 5px 10px;
  text-transform: uppercase;
  cursor: pointer;
  transition: border-color 0.15s, color 0.15s;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
.feedback-btn:hover {
  border-color: var(--accent);
  color: var(--text);
}
.feedback-btn.active {
  border-color: var(--accent);
  color: #fff;
  background: rgba(124, 92, 252, 0.2);
}
.feedback-btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
}
.infinite-btn.active {
  border-color: var(--gold);
  color: #fff;
  background:
    linear-gradient(
      90deg,
      rgba(217, 119, 6, 0.34) 0%,
      rgba(217, 119, 6, 0.34) var(--loop-progress, 0%),
      rgba(24, 24, 40, 0.96) var(--loop-progress, 0%),
      rgba(24, 24, 40, 0.96) 100%
    );
}
.cadence-wrap {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  border: 1px solid var(--border2);
  border-radius: 6px;
  background:
    linear-gradient(
      90deg,
      rgba(217, 119, 6, 0.26) 0%,
      rgba(217, 119, 6, 0.26) var(--cad-progress, 0%),
      rgba(24, 24, 40, 0.96) var(--cad-progress, 0%),
      rgba(24, 24, 40, 0.96) 100%
    );
}
.cadence-label {
  font-size: 9px;
  letter-spacing: 0.6px;
  color: var(--muted);
  text-transform: uppercase;
  white-space: nowrap;
}
.cadence-slider {
  width: 110px;
  accent-color: var(--gold);
  cursor: pointer;
}
.cadence-wrap.disabled {
  opacity: 0.45;
}
.cadence-wrap.disabled .cadence-slider {
  cursor: not-allowed;
}
.cadence-wrap.timing {
  border-color: rgba(217, 119, 6, 0.55);
}
.fish-scale-wrap {
  height: 26px;
  box-sizing: border-box;
  flex: 0 0 210px;
  min-width: 210px;
  max-width: 210px;
  gap: 6px;
  padding-top: 0;
  padding-bottom: 0;
  padding-right: 4px;
}
.fish-scale-wrap .cadence-slider {
  flex: 0 0 60%;
  min-width: 0;
  width: 60%;
  max-width: 60%;
  margin: 0;
  padding: 0;
}
.fish-scale-wrap .cadence-label {
  white-space: nowrap;
}
.infinite-feedback-msg {
  margin-top: 8px;
  font-size: 10px;
  letter-spacing: 0.5px;
  color: #f5b763;
  text-transform: uppercase;
  opacity: 0;
  max-height: 0;
  overflow: hidden;
  transition: opacity 0.45s ease, max-height 0.45s ease;
}
.infinite-feedback-msg.visible {
  opacity: 1;
  max-height: 24px;
}
.godmode-toast {
  position: fixed;
  top: 14px;
  right: 14px;
  z-index: 1200;
  background: rgba(12, 12, 20, 0.92);
  border: 1px solid rgba(124, 92, 252, 0.55);
  border-radius: 8px;
  color: #ddd9ff;
  font-size: 10px;
  letter-spacing: 0.9px;
  text-transform: uppercase;
  padding: 7px 10px;
  opacity: 0;
  transform: translateY(-6px);
  pointer-events: none;
  transition: opacity 0.35s ease, transform 0.35s ease;
}
.godmode-toast.visible {
  opacity: 1;
  transform: translateY(0);
}

/* ═══════════════════════════════
   COLLAPSIBLE SECTIONS
═══════════════════════════════ */
.collapse-btn {
  background: none;
  border: 1px solid var(--border2);
  border-radius: 4px;
  color: var(--muted);
  font-size: 9px;
  letter-spacing: 1px;
  text-transform: uppercase;
  font-weight: 600;
  padding: 2px 8px;
  cursor: pointer;
  font-family: inherit;
  transition: color 0.15s, border-color 0.15s;
  line-height: 1.6;
}
.collapse-btn:hover { color: var(--text); border-color: var(--accent); }
.collapsible-body {
  overflow: hidden;
  transition: max-height 0.25s ease, opacity 0.2s ease;
  max-height: 600px;
  opacity: 1;
}
.collapsible-body.collapsed {
  max-height: 0;
  opacity: 0;
}

/* ═══════════════════════════════
   HISTORY TOOLTIP
═══════════════════════════════ */
.history-item {
  position: relative;
}
.history-tooltip {
  display: none;
  position: fixed;
  z-index: 999;
  background: var(--surface2);
  border: 1px solid var(--accent);
  border-radius: 10px;
  padding: 14px 18px;
  font-size: 13px;
  line-height: 1.8;
  color: #d0d0e8;
  max-width: 420px;
  max-height: 320px;
  overflow-y: auto;
  box-shadow: 0 8px 40px rgba(0,0,0,0.6);
  pointer-events: none;
}
.history-tooltip::-webkit-scrollbar { width: 3px; }
.history-tooltip::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }
.history-tooltip.visible { display: block; }

/* ═══════════════════════════════
   MOBILE / TOUCH
═══════════════════════════════ */
@media (max-width: 700px) {
  .row { padding: 12px 14px; }
  .mixer-section { padding: 12px 14px; }
  .current-wrap { padding: 12px 14px; }

  /* Reorder: source → output → mixer → concepts → rest */
  .row-source       { order: 1; }
  .row-food         { order: 1; }
  .current-wrap     { order: 2; }
  .mixer-section    { order: 3; }
  .row-concepts     { order: 4; }
  .row-trawl        { order: 5; }
  .row-prompt       { order: 6; }
  .row-base-prompt  { order: 7; }
  .row-history      { order: 8; }

  /* Taller mixer so chips have room */
  .mixer-wrap { height: 360px; }

  /* Stack sensibility boxes vertically on narrow screens */
  .sensibility-row { flex-direction: column; gap: 8px; }
  .sensibility-box { width: 100%; }
  .sensibility-controls { width: 100%; order: 1; justify-content: flex-start; }
  .sensibility-box.left { order: 2; }
  .sensibility-box.right { order: 3; }
  .sensibility-box.right { text-align: left; }
  .sensibility-box.right .sensibility-label { text-align: left; }

  /* Slightly more padding for fat fingers, but keep compact */
  .chip-pill { padding: 4px 7px !important; }
  .word-chip { width: 80px; }

  /* Stack the output header on small screens */
  .row-label { flex-wrap: wrap; gap: 6px; }
  .current-head {
    justify-content: flex-start !important;
    align-items: flex-start !important;
  }
  .current-head-right {
    width: 100%;
    flex-wrap: wrap;
    gap: 8px !important;
  }
  .current-head-right .model-select {
    flex: 1 1 160px;
    min-width: 150px;
  }
  .current-head-right .cadence-wrap {
    flex: 1 1 170px;
    min-width: 160px;
  }
  .current-head-right .feedback-btn {
    flex: 0 0 auto;
  }

  .output-current { max-height: none; }

  .sentence-row { flex-direction: column; }
  .trawl-row { gap: 6px; }
  .trawl-input { font-size: 11px; }
}

@media (max-width: 900px) {
  .sensibility-row {
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }
  .sensibility-controls {
    width: 100%;
    order: 1;
    justify-content: flex-start;
    flex-wrap: wrap;
    white-space: normal;
  }
  .sensibility-box.left {
    order: 2;
    width: 100%;
    flex: 0 0 auto;
    min-width: 0;
  }
  .sensibility-box.right {
    order: 3;
    width: 100%;
    flex: 0 0 auto;
    min-width: 0;
    text-align: left;
  }
  .fish-scale-wrap {
    flex: 0 0 210px;
    min-width: 210px;
    max-width: 210px;
  }
}
</style>
</head>
<body>
<div class="page">

  <!-- 1. SOURCE PARAGRAPH -->
  <div class="row row-source" id="row-source">
    <div class="row-label" title="This is what I'm thinking about, an idea that the fish in the tank will transform">Thought</div>
    <textarea id="mission" rows="3" oninput="scheduleUpdate(800)">deep thought</textarea>
  </div>

  <div class="row row-food" id="row-food" style="display:none;">
    <div class="row-label" title="In feedback mode the output is the input, so this box was defunct. To make use for it, it is now food for thought, it will steer the model in a particular way in feedback mode, try something like REPLY IN CAPS">
      Food for thought
      <label title="If you use this then it isn't really feedback mode any more, but it allows you to get behaviour like infinite feedback mode (i.e., endless generations) but with a static thought" style="display:flex;align-items:center;gap:5px;cursor:pointer;font-size:10px;letter-spacing:1px;color:var(--muted);text-transform:uppercase;font-weight:600;user-select:none;">
        <input type="checkbox" id="you-are-what-you-eat" onchange="onYouAreWhatYouEatChange()" style="width:12px;height:12px;cursor:pointer;">
        You are what you eat
      </label>
    </div>
    <textarea id="food-for-thought" rows="3" oninput="scheduleUpdate(800)" placeholder="A sentiment appended to the end of the prompt while infinite feedback is on." title="A sort of hint or direction that is appended to a prompt when in feedback mode (i.e., 'food for thought')."></textarea>
  </div>
  <!-- 4. CURRENT OUTPUT + MODEL CHOOSER -->
  <div class="current-wrap">
    <div class="row-label current-head" style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
      <div style="display:flex;align-items:center;gap:12px;">
        <div class="live-badge"><div class="live-dot" id="live-dot"></div><span id="current-io-label" title="This changes to say Current I/O (rather than Current Output) when in feedback mode">Current output</span></div>
        <label title="The answers will be much longer if you don't tick this, maybe you like it long" style="display:flex;align-items:center;gap:5px;cursor:pointer;font-size:10px;letter-spacing:1px;color:var(--muted);text-transform:uppercase;font-weight:600;user-select:none;">
          <input type="checkbox" id="keep-brief" checked onchange="scheduleUpdate(0)" style="width:12px;height:12px;cursor:pointer;">
          Force short output
        </label>
      </div>
      <div class="current-head-right" style="display:flex;align-items:center;gap:10px;">
        <select class="model-select" id="model-select" onchange="onModelChange()" title="The groq models are faster, sonnet is smarter, no right or wrong, just different">
          <option value="google/gemini-3.1-pro-preview">Gemini 3.1 Pro</option>
          <option value="anthropic/claude-sonnet-4.6">Claude Sonnet 4.6</option>
          <option value="qwen/qwen3.5-plus-02-15">Qwen 3.5 Plus</option>
          <option value="x-ai/grok-4.1-fast">Grok 4.1 Fast</option>
          <option value="google/gemini-3-flash-preview">Gemini 3 Flash</option>
          <option value="google/gemini-2.5-flash-lite-preview-09-2025">Gemini 2.5 Flash Lite</option>
          <option value="groq:openai/gpt-oss-20b">Groq GPT-OSS 20B</option>
          <option value="groq:groq/compound-mini">Groq Compound Mini</option>
<option value="groq:openai/gpt-oss-120b">Groq GPT-OSS 120B</option>
<option value="groq:llama-3.1-8b-instant">Groq LLaMA 3.1 8B Instant</option>
<option value="groq:llama-3.3-70b-versatile" selected>Groq LLaMA 3.3 70B Versatile</option>
<option value="groq:moonshotai/kimi-k2-instruct-0905">Groq Kimi K2 Instruct 0905</option>
        </select>
        <div class="cadence-wrap" id="cadence-wrap">
          <span class="cadence-label">Fast</span>
          <input class="cadence-slider" id="infinite-cadence" type="range" min="0" max="5000" step="50" value="2500" oninput="updateCadenceLabel()" title="Speed limit on generations">
          <span class="cadence-label">Slow</span>
        </div>
        <button class="feedback-btn" id="theme-toggle-btn" title="Toggle light/dark mode">Light</button>
        <button class="feedback-btn" id="feedback-btn" title="Where usually the text in the Thought box is what the model is thinking about, with FDBK on it will think about the last thing it generated, last thing it generated, last thing it generated - get it?">fdbk</button>
        <button class="feedback-btn infinite-btn" id="infinite-feedback-btn" title="With this on the model won't stop after each generation, it'll just keep going (which it will do anyway if Fish Physics mode is on)">∞</button>
      </div>
    </div>
    <div class="infinite-feedback-msg" id="infinite-feedback-msg"></div>
    <div class="output-with-controls">
      <div class="output-current" id="output-current" title="If you are in feedback mode then you can type in this box, doing so will get the model - just that one time - to think about what you type. So, when it's feeding back you can send it off in new directions">
        Attempting first contact with an API...
      </div>
      <div class="output-size-controls">
        <button class="output-size-btn" onclick="adjustOutputWindowHeight(1)" title="Add rows to the output box">+</button>
        <button class="output-size-btn" onclick="adjustOutputWindowHeight(-1)" title="Remove rows from output box">-</button>
      </div>
    </div>
  </div>

  <!-- 2. CONCEPT MIXER with sensibility boxes below -->
  <div class="mixer-section">
    <div class="row-label" title="The thinking tank, filled with little fishes">
      PthinkTank
      <span style="font-size:9px;color:var(--muted);text-transform:none;letter-spacing:0;font-weight:400;">
        — drag ↑↓ weight &nbsp; ←→ lean towards one of two sensibilities
      </span>
    </div>
    <!-- Mixer canvas (full width) -->
    <div class="mixer-wrap" id="mixer">
      <div class="ascii-bg-layer" id="ascii-bg-layer">
        <iframe class="ascii-bg-frame" id="ascii-bg-frame" title="Fish background animation" loading="lazy" tabindex="-1" aria-hidden="true"></iframe>
      </div>
      <div class="guide" style="top:25%"></div>
      <div class="guide" style="top:50%"></div>
      <div class="guide" style="top:75%"></div>
      <div class="deadzone-band" id="deadzone-band"></div>
      <div class="axis-left" id="axis-left" onclick="document.getElementById('axis-pick-1').click()" title="Choose a color for the fish backgrounds to go the closer you move them towards the left/right of the PThinkTank">← Sensibility 1</div>
      <div class="axis-right" id="axis-right" onclick="document.getElementById('axis-pick-2').click()" title="Choose a color for the fish backgrounds to go the closer you move them towards the left/right of the PThinkTank">Sensibility 2 →</div>
      <input type="color" id="axis-pick-1" class="axis-color-pick" value="#ec4899" oninput="renderChips()">
      <input type="color" id="axis-pick-2" class="axis-color-pick" value="#34d399" oninput="renderChips()">
      <canvas class="pong-canvas" id="pong-canvas"></canvas>
      <div class="fx-layer" id="fx-layer"></div>
      <div class="shark-layer" id="shark-layer">
        <div class="shark-run" id="shark-run">
          <div class="black-hole"></div>
          <svg class="vf-single" viewBox="0 0 90 42" aria-hidden="true">
            <path d="M8 22 C18 8 40 5 63 11 C74 13 81 16 85 21 C81 26 74 29 63 31 C40 37 18 34 8 22 Z" fill="#1e293b" stroke="rgba(147,197,253,0.7)" stroke-width="1.2"></path>
            <path d="M63 21 L83 10 L83 32 Z" fill="#0f172a"></path>
            <polygon points="40,12 50,2 49,15" fill="#334155"></polygon>
            <path d="M25 20 L46 20 L43 24 L40 20 L37 24 L34 20 L31 24 L28 20 Z" fill="#f8fafc"></path>
            <circle cx="24" cy="18" r="2.2" fill="#020617"></circle>
          </svg>
          <div class="bh-spark" style="--i:0;"></div>
          <div class="bh-spark" style="--i:1;"></div>
          <div class="bh-spark" style="--i:2;"></div>
          <div class="bh-spark" style="--i:3;"></div>
          <div class="bh-spark" style="--i:4;"></div>
          <div class="bh-spark" style="--i:5;"></div>
          <div class="bh-spark" style="--i:6;"></div>
          <div class="bh-spark" style="--i:7;"></div>
          <div class="bh-spark" style="--i:8;"></div>
          <div class="bh-spark" style="--i:9;"></div>
          <div class="bh-spark" style="--i:10;"></div>
          <div class="bh-spark" style="--i:11;"></div>
        </div>
      </div>
      <div class="mixer-empty" id="mixer-empty">
        <div class="mixer-empty-icon">⟳</div>
        Type transformation concepts below
      </div>
    </div>
    <!-- Sensibility boxes below, left and right -->
    <div class="sensibility-row">
      <div class="sensibility-box left">
        <div class="sensibility-combo">
          <input id="direction-1" type="text" oninput="renderChips();scheduleUpdate(800)" placeholder="e.g. poetic and lyrical" value="" autocomplete="off" title="You can choose or type a sensibility here, when fish move closer to this edge of the tank, the sensibility will have more of an impact on the output">
          <button type="button" class="combo-arrow" id="direction-1-arrow" aria-label="Show sensibility 1 options">&#9662;</button>
          <div class="combo-list" id="direction-1-list"></div>
        </div>
        <datalist id="direction-1-options">
          <option value="shimmer"></option>
          <option value="dwindle"></option>
          <option value="bramble"></option>
          <option value="nestle"></option>
          <option value="embers"></option>
          <option value="tremble"></option>
          <option value="calcify"></option>
          <option value="petrify"></option>
          <option value="luminous"></option>
          <option value="cavernous"></option>
          <option value="undulate"></option>
          <option value="cathedral"></option>
          <option value="porcelain"></option>
          <option value="cinnamon"></option>
          <option value="mercury"></option>
          <option value="silhouette"></option>
          <option value="carnivore"></option>
          <option value="pendulum"></option>
          <option value="gossamer"></option>
          <option value="splinter"></option>
          <option value="hollow"></option>
          <option value="pilgrim"></option>
          <option value="labyrinth"></option>
          <option value="corridor"></option>
          <option value="tambourine"></option>
          <option value="marmalade"></option>
          <option value="effervesce"></option>
          <option value="cascade"></option>
          <option value="smother"></option>
          <option value="flutter"></option>
          <option value="murmur"></option>
        </datalist>
      </div>
      <div class="sensibility-box sensibility-controls">
        <button class="feedback-btn" id="chip-physics-btn" title="The physics of fish, clearly">fish physics</button>
        <button class="feedback-btn" id="rnd-btn" title="Makes the fish swim off in random directions">rnd</button>
        <button class="feedback-btn" id="bmp-btn" title="Fish either swim through each other, or bump off each other - this chooses which">bmp</button>
        <div class="cadence-wrap fish-scale-wrap" id="fish-scale-wrap" title="Scales the swimming speed of the fish">
          <span class="cadence-label">fish scale</span>
          <input class="cadence-slider" id="fish-speed-scale" type="range" min="-100" max="100" step="1" value="0" oninput="updateFishScaleLabel()" title="Scales the swimming speed of the fish">
        </div>
      </div>
      <div class="sensibility-box right">
        <div class="sensibility-combo">
          <input id="direction-2" type="text" oninput="renderChips();scheduleUpdate(800)" placeholder="e.g. clinical and precise" value="" autocomplete="off" title="You can choose or type a sensibility here, when fish move closer to this edge of the tank, the sensibility will have more of an impact on the output">
          <button type="button" class="combo-arrow" id="direction-2-arrow" aria-label="Show sensibility 2 options">&#9662;</button>
          <div class="combo-list" id="direction-2-list"></div>
        </div>
        <datalist id="direction-2-options">
          <option value="slither"></option>
          <option value="kindle"></option>
          <option value="ramble"></option>
          <option value="wrestle"></option>
          <option value="remember"></option>
          <option value="resemble"></option>
          <option value="lullaby"></option>
          <option value="butterfly"></option>
          <option value="ominous"></option>
          <option value="ravenous"></option>
          <option value="percolate"></option>
          <option value="ephemeral"></option>
          <option value="origin"></option>
          <option value="phenomenon"></option>
          <option value="reverie"></option>
          <option value="marionette"></option>
          <option value="metaphor"></option>
          <option value="tantrum"></option>
          <option value="philosopher"></option>
          <option value="winter"></option>
          <option value="swallow"></option>
          <option value="algorithm"></option>
          <option value="amaranth"></option>
          <option value="matador"></option>
          <option value="kerosene"></option>
          <option value="barricade"></option>
          <option value="coalesce"></option>
          <option value="masquerade"></option>
          <option value="slumber"></option>
          <option value="gutter"></option>
          <option value="smolder"></option>
        </datalist>
      </div>
    </div>
    <div class="mixer-resize-handle" id="mixer-resize-handle" title="Drag to resize PthinkTank"></div>
  </div>

  <!-- 3. TRANSFORMATION CONCEPTS -->
  <div class="row row-concepts">
    <div class="row-label" title="Trout, Salmon, Flouder, Frog.. etc">fish</div>
    <div class="sentence-row">
      <!-- Hidden real textarea keeps value in sync for buildPrompt -->
      <textarea id="sentence-input">animal, vegetable, mineral</textarea>
      <!-- Visible tag input -->
      <div class="tag-input-wrap" id="tag-input-wrap">
        <input class="tag-input-field" id="tag-input-field" type="text" placeholder="type a concept, press comma…" autocomplete="off" spellcheck="false">
      </div>
    </div>
  </div>

  <div class="row row-trawl">
    <div class="row-label" title="You can use this to be lazy and create a new Thought and several new fish. Uses the same model that's selected, just for testing really.">
      Trawl
      <button class="collapse-btn" id="trawl-toggle-btn" onclick="toggleTrawlRow()">show</button>
    </div>
    <div class="trawl-row" id="trawl-row-body" style="display:none;">
      <input class="trawl-input" id="trawl-thought" type="text" placeholder="What are you thinking?" autocomplete="off">
      <input class="trawl-input" id="trawl-fish" type="text" placeholder="What kind of fish do you want?" autocomplete="off">
      <button class="feedback-btn" id="trawl-haul-btn">Haul</button>
    </div>
  </div>


  <!-- 5. GENERATED PROMPT (preview) -->
  <div class="row row-prompt">
    <div class="row-label" title="What you see in this box is what is sent to the model">
      Generated prompt
      <button class="collapse-btn" onclick="toggleCollapse('generated-prompt-body', this)">show</button>
    </div>
    <div class="collapsible-body collapsed" id="generated-prompt-body">
      <div class="prompt-block" id="generated-prompt">—</div>
    </div>
  </div>

  <!-- 6. BASE PROMPT TEMPLATE -->
  <div class="row row-base-prompt">
    <div class="row-label" title="You can edit the preamble and ending of the prompt, good for fine tuning towards particular outputs. When you save it will actually be saved to a file and come back if you refresh the page. Reset to hardcoded will overwrite that file">
      Base prompt template
      <button class="collapse-btn" onclick="toggleCollapse('base-prompt-body', this)">show</button>
      <button class="collapse-btn" id="reset-hardcoded-prompts-btn" onclick="resetToHardcodedPrompts()" title="Overwrites any saved prompt files with the original hardcoded ones">reset to hardcoded prompt</button>
      <span id="prompt-template-status" style="font-size:9px;letter-spacing:1px;color:var(--muted);text-transform:none;"></span>
    </div>
    <div class="collapsible-body collapsed" id="base-prompt-body">
      <div class="base-prompt-editor" id="base-editor">
        <div>
          <label>Preamble <button class="collapse-btn" type="button" id="save-preamble-btn" onclick="savePromptSection('preamble')">save</button></label>
          <textarea id="base-preamble" rows="3" oninput="scheduleUpdate(800)">You have several transformation concepts to apply to the thought. Each has two properties:
- Weight (0.00 = ignore, 1.00 = apply strongly)
- Optionally, lean toward a sensibility</textarea>
        </div>
        <div>
          <label>Closing instruction <button class="collapse-btn" type="button" id="save-closing-btn" onclick="savePromptSection('closing')">save</button></label>
          <textarea id="base-closing" rows="4" oninput="scheduleUpdate(800)">Reimagine the original thought applying these transformations proportionally.
Higher-weighted concepts should have a more visible effect on the output.
Concepts that lean toward a sensibility should pull the style in that direction.
Preserve the core meaning of the original thought.
Only output your new idea, no meta commentary, none of the original prompt.</textarea>
        </div>
      </div>
    </div>
  </div>

  <!-- 7. PREVIOUS OUTPUTS -->
  <div class="row row-history">
    <div class="row-label" style="margin-bottom:6px" title="Self explanatory, if you click one then that state should be loaded back in (if fish mode enabled then.. good luck)">Previous outputs</div>
    <div class="history-empty" id="history-empty">
      Previous outputs will appear here as you adjust the mixer.
    </div>
    <div id="history-list"></div>
  </div>

  <div class="row" style="display:flex;justify-content:center;align-items:center;padding-top:10px;padding-bottom:12px;">
    <a href="https://designresearch.works/" target="_blank" rel="noopener noreferrer" aria-label="Design Research Works" style="display:inline-flex;align-items:center;gap:8px;color:var(--muted);text-decoration:none;">
      <img src="logo.png" alt="Design Research Works logo" style="width:32px;height:32px;display:block;" />
    </a>
  </div>

</div><!-- /page -->

<!-- Floating history tooltip -->
<div class="history-tooltip" id="history-tooltip"></div>
<div class="godmode-toast" id="godmode-toast">god mode enabled</div>

<script>
/* ═══════════════════════════════
   DATA
═══════════════════════════════ */
var words = [];
var outputHistory  = [];
var currentOutput  = '';
var feedbackModeEnabled = false;
var infiniteFeedbackEnabled = false;
var infiniteCadenceValue = 2500;
var isStreaming    = false;
var pendingPrompt  = null;
var inFlightPrompt = null;
var infiniteCountdownTimer = null;
var infiniteCountdownRaf = null;
var infiniteInactivityInterval = null;
var conceptLastMoveTs = Date.now();
var INFINITE_INACTIVITY_MS = 30000;
var chipPhysicsEnabled = false;
var chipPhysicsBmpMode = false;
var chipPhysicsRaf = null;
var chipPhysicsLastTs = 0;
var chipPhysicsNextPromptTs = 0;
var chipPhysicsLastRenderTs = 0;
var dragLastSampleTs = 0;
var dragLastSampleXFrac = 0;
var dragLastSampleYFrac = 0;
var chipPhysicsMaxSpeed = 0.9; // frac units per second
var chipSpeedScalePct = 0; // -100..100
var chipSpeedScale = 1.0; // 0.0..2.0
var chipScaleBase = 0.902;
var chipScaleWeightFactor = 0.584;
var rndBaseMinFactor = 0.35;
var rndBaseMaxFactor = 0.65;
var rndLaunchMinFactor = 0.10;
var rndLaunchMaxFactor = 0.40;
var modelProgressDefaultMs = 3000;
var MIXER_BOUND_PAD_X = 26;
var MIXER_BOUND_PAD_TOP_Y = 28;
var MIXER_BOUND_PAD_BOTTOM_Y = 3;
var generationSafetyPaused = false;
var pPressTimes = [];
var pongModeActive = false;
var pongState = null;
var pongRaf = null;
var GODMODE_FEATURE_ENABLED = true;
var godmodeEnabled = false;
var godmodeBuffer = '';
var godmodeToastTimer = null;
var outputWindowHeightPx = 0;
var modelTiming = { modelId: null, avgMs: 0, count: 0 };
var requestProgressRaf = null;
var requestStartTs = 0;
var lastTouchTapTs = 0;
var lastTouchUiTs = 0;
var TOUCH_UI_GRACE_MS = 320;
var lastGenerateStartTs = 0;
var generateThrottleTimer = null;
var cadenceProgressRaf = null;
var cadenceProgressStartTs = 0;
var cadenceProgressDelayMs = 0;
var cadenceProgressActiveCheck = null;
var trawlInFlight = false;
var mixerResizeActive = false;
var mixerResizeStartY = 0;
var mixerResizeStartH = 0;
var currentOutputEditActive = false;
var manualOutputEditPause = false;
var outputTouchStartX = 0;
var outputTouchStartY = 0;
var outputTouchStartTs = 0;
var outputLastTapTs = 0;
var hardcodedBasePreamble = '';
var hardcodedBaseClosing = '';
var promptTemplateStatusTimer = null;

/* ═══════════════════════════════
   DRAG STATE
═══════════════════════════════ */
var draggingKey     = null;
var dragStartMouseX = 0;
var dragStartMouseY = 0;
var dragStartXFrac  = 0;
var dragStartYFrac  = 0;
var selectedKey     = null;
var stateDirtyWhileStreaming = false;
var mergeHoverTargetKey = null;
var mergeHoverSinceTs = 0;
var MERGE_HOLD_MS = 1000;
var joinGlowRaf = null;
var JOIN_GLOW_MS = 650;
var mergeHoldProgress = 0;
var mergeHoldRaf = null;
var dragPointerX = 0;
var dragPointerY = 0;
var sharkRunTimer = null;
var asciiBgLoaded = false;
var asciiBgDisabled = false;
var fishAsciiBuffer = '';
var uiTheme = 'dark';
var uiDefaultTheme = 'dark';
var appConfig = {};
var DEFAULT_APP_CONFIG = {
  default_theme: 'dark',
  default_model: 'groq:llama-3.3-70b-versatile',
  default_thought: 'deep thought',
  default_fish_concepts: 'animal, vegetable, mineral',
  cadence_min_ms: 0,
  cadence_max_ms: 5000,
  cadence_default_ms: 2500,
  infinite_inactivity_ms: 30000,
  touch_ui_grace_ms: 320,
  chip_max_speed: 0.9,
  fish_scale_min_pct: -100,
  fish_scale_max_pct: 100,
  fish_scale_default_pct: 0,
  chip_scale_base: 0.902,
  chip_scale_weight_factor: 0.584,
  rnd_base_min_factor: 0.35,
  rnd_base_max_factor: 0.65,
  rnd_launch_min_factor: 0.10,
  rnd_launch_max_factor: 0.40,
  deadzone_half: 0.10,
  merge_hold_ms: 1000,
  join_glow_ms: 650,
  model_progress_default_ms: 3000
};

/* ═══════════════════════════════
   SIMPLE MARKDOWN RENDERER
═══════════════════════════════ */
function simpleMarkdown(text) {
  if (!text) return '';
  var s = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
  s = s.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  s = s.replace(/^## (.+)$/gm,  '<h2>$1</h2>');
  s = s.replace(/^# (.+)$/gm,   '<h1>$1</h1>');
  s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/__(.+?)__/g,     '<strong>$1</strong>');
  s = s.replace(/\*(.+?)\*/g, '<em>$1</em>');
  s = s.replace(/^[\-\*] (.+)$/gm, '<li>$1</li>');
  s = s.replace(/((?:<li>.*<\/li>\n?)+)/g, '<ul>$1</ul>');
  s = s.replace(/\n\n+/g, '</p><p>');
  s = s.replace(/\n/g, '<br>');
  s = '<p>' + s + '</p>';
  s = s.replace(/<p><\/p>/g, '');
  return s;
}

function applyUiTheme(theme) {
  var root = document.documentElement;
  uiTheme = (theme === 'light') ? 'light' : 'dark';
  root.setAttribute('data-theme', uiTheme);
  var btn = document.getElementById('theme-toggle-btn');
  if (btn) {
    btn.classList.toggle('active', uiTheme === 'light');
    btn.textContent = (uiTheme === 'light') ? 'Dark' : 'Light';
  }
}

function initUiTheme() {
  var stored = '';
  try { stored = localStorage.getItem('prompt_mixer_theme') || ''; } catch (e) {}
  applyUiTheme(stored || uiDefaultTheme || 'dark');
}

function toggleUiTheme() {
  var next = uiTheme === 'light' ? 'dark' : 'light';
  applyUiTheme(next);
  try { localStorage.setItem('prompt_mixer_theme', next); } catch (e) {}
}

function normalizeAppConfig(raw) {
  var cfg = Object.assign({}, DEFAULT_APP_CONFIG, raw || {});
  function num(key, fallback) {
    var v = Number(cfg[key]);
    return isFinite(v) ? v : fallback;
  }
  function intNum(key, fallback) {
    return Math.round(num(key, fallback));
  }
  cfg.default_model = String(cfg.default_model || DEFAULT_APP_CONFIG.default_model);
  cfg.default_theme = (String(cfg.default_theme || DEFAULT_APP_CONFIG.default_theme).toLowerCase() === 'light') ? 'light' : 'dark';
  cfg.default_thought = String(cfg.default_thought || DEFAULT_APP_CONFIG.default_thought);
  cfg.default_fish_concepts = String(cfg.default_fish_concepts || DEFAULT_APP_CONFIG.default_fish_concepts);

  cfg.cadence_min_ms = Math.max(0, intNum('cadence_min_ms', DEFAULT_APP_CONFIG.cadence_min_ms));
  cfg.cadence_max_ms = Math.max(cfg.cadence_min_ms, intNum('cadence_max_ms', DEFAULT_APP_CONFIG.cadence_max_ms));
  cfg.cadence_default_ms = Math.max(cfg.cadence_min_ms, Math.min(cfg.cadence_max_ms, intNum('cadence_default_ms', DEFAULT_APP_CONFIG.cadence_default_ms)));
  cfg.infinite_inactivity_ms = Math.max(5000, intNum('infinite_inactivity_ms', DEFAULT_APP_CONFIG.infinite_inactivity_ms));
  cfg.touch_ui_grace_ms = Math.max(0, intNum('touch_ui_grace_ms', DEFAULT_APP_CONFIG.touch_ui_grace_ms));
  cfg.chip_max_speed = Math.max(0.05, num('chip_max_speed', DEFAULT_APP_CONFIG.chip_max_speed));

  cfg.fish_scale_min_pct = Math.max(-200, Math.min(0, intNum('fish_scale_min_pct', DEFAULT_APP_CONFIG.fish_scale_min_pct)));
  cfg.fish_scale_max_pct = Math.max(cfg.fish_scale_min_pct, Math.min(400, intNum('fish_scale_max_pct', DEFAULT_APP_CONFIG.fish_scale_max_pct)));
  cfg.fish_scale_default_pct = Math.max(cfg.fish_scale_min_pct, Math.min(cfg.fish_scale_max_pct, intNum('fish_scale_default_pct', DEFAULT_APP_CONFIG.fish_scale_default_pct)));

  cfg.chip_scale_base = Math.max(0.2, Math.min(3.0, num('chip_scale_base', DEFAULT_APP_CONFIG.chip_scale_base)));
  cfg.chip_scale_weight_factor = Math.max(0.0, Math.min(3.0, num('chip_scale_weight_factor', DEFAULT_APP_CONFIG.chip_scale_weight_factor)));

  cfg.rnd_base_min_factor = Math.max(0.0, Math.min(2.0, num('rnd_base_min_factor', DEFAULT_APP_CONFIG.rnd_base_min_factor)));
  cfg.rnd_base_max_factor = Math.max(cfg.rnd_base_min_factor, Math.min(2.0, num('rnd_base_max_factor', DEFAULT_APP_CONFIG.rnd_base_max_factor)));
  cfg.rnd_launch_min_factor = Math.max(0.0, Math.min(2.0, num('rnd_launch_min_factor', DEFAULT_APP_CONFIG.rnd_launch_min_factor)));
  cfg.rnd_launch_max_factor = Math.max(cfg.rnd_launch_min_factor, Math.min(2.0, num('rnd_launch_max_factor', DEFAULT_APP_CONFIG.rnd_launch_max_factor)));

  cfg.deadzone_half = Math.max(0.0, Math.min(0.49, num('deadzone_half', DEFAULT_APP_CONFIG.deadzone_half)));
  cfg.merge_hold_ms = Math.max(200, intNum('merge_hold_ms', DEFAULT_APP_CONFIG.merge_hold_ms));
  cfg.join_glow_ms = Math.max(100, intNum('join_glow_ms', DEFAULT_APP_CONFIG.join_glow_ms));
  cfg.model_progress_default_ms = Math.max(300, intNum('model_progress_default_ms', DEFAULT_APP_CONFIG.model_progress_default_ms));
  return cfg;
}

function applyAppConfig(raw) {
  var cfg = normalizeAppConfig(raw);
  appConfig = cfg;
  uiDefaultTheme = cfg.default_theme;

  infiniteCadenceValue = cfg.cadence_default_ms;
  INFINITE_INACTIVITY_MS = cfg.infinite_inactivity_ms;
  TOUCH_UI_GRACE_MS = cfg.touch_ui_grace_ms;
  chipPhysicsMaxSpeed = cfg.chip_max_speed;
  DEADZONE_HALF = cfg.deadzone_half;
  MERGE_HOLD_MS = cfg.merge_hold_ms;
  JOIN_GLOW_MS = cfg.join_glow_ms;
  chipScaleBase = cfg.chip_scale_base;
  chipScaleWeightFactor = cfg.chip_scale_weight_factor;
  rndBaseMinFactor = cfg.rnd_base_min_factor;
  rndBaseMaxFactor = cfg.rnd_base_max_factor;
  rndLaunchMinFactor = cfg.rnd_launch_min_factor;
  rndLaunchMaxFactor = cfg.rnd_launch_max_factor;
  modelProgressDefaultMs = cfg.model_progress_default_ms;

  var cadence = document.getElementById('infinite-cadence');
  if (cadence) {
    cadence.min = String(cfg.cadence_min_ms);
    cadence.max = String(cfg.cadence_max_ms);
    cadence.value = String(cfg.cadence_default_ms);
  }

  var fishScale = document.getElementById('fish-speed-scale');
  if (fishScale) {
    fishScale.min = String(cfg.fish_scale_min_pct);
    fishScale.max = String(cfg.fish_scale_max_pct);
    fishScale.value = String(cfg.fish_scale_default_pct);
  }

  var mission = document.getElementById('mission');
  if (mission) mission.value = cfg.default_thought;
  var conceptsHidden = document.getElementById('sentence-input');
  if (conceptsHidden) conceptsHidden.value = cfg.default_fish_concepts;
  var modelSelect = document.getElementById('model-select');
  if (modelSelect && Array.from(modelSelect.options).some(function(o) { return o.value === cfg.default_model; })) {
    modelSelect.value = cfg.default_model;
  }

  // Config default_theme is authoritative for initial page theme.
  applyUiTheme(uiDefaultTheme);
  try { localStorage.setItem('prompt_mixer_theme', uiDefaultTheme); } catch (e) {}

  if (typeof tagTokens !== 'undefined' && conceptsHidden) {
    tagTokens = normaliseConceptTokens((conceptsHidden.value || '').split(','));
    if (typeof tagRender === 'function') tagRender();
    if (typeof tagSyncTextarea === 'function') tagSyncTextarea();
    if (typeof syncWordsToTagTokens === 'function') syncWordsToTagTokens({ schedule: false });
  }

  updateCadenceLabel();
  updateFishScaleLabel();
  renderChips();
  onModelChange(false);
}

async function loadAppConfig() {
  try {
    var res = await fetch('/api/app-config');
    if (!res.ok) {
      applyAppConfig(DEFAULT_APP_CONFIG);
      return;
    }
    var data = await res.json();
    applyAppConfig((data && data.config) || DEFAULT_APP_CONFIG);
  } catch (err) {
    applyAppConfig(DEFAULT_APP_CONFIG);
  }
}

function maybeTriggerPongEasterEgg(key) {
  if (!key) return;
  if (key.toLowerCase() !== 'p') {
    pPressTimes = [];
    return;
  }

  var now = performance.now();
  pPressTimes.push(now);
  pPressTimes = pPressTimes.filter(function(ts) { return (now - ts) <= 1600; });
  if (pPressTimes.length >= 7) {
    pPressTimes = [];
    startPongMode();
  }
}

function maybeTriggerGodmode(key) {
  if (!GODMODE_FEATURE_ENABLED) return;
  if (!key || key.length !== 1 || !/[a-z]/i.test(key)) return;
  godmodeBuffer += key.toLowerCase();
  if (godmodeBuffer.length > 32) godmodeBuffer = godmodeBuffer.slice(-32);
  if (godmodeBuffer.endsWith('godmode')) {
    godmodeBuffer = '';
    godmodeEnabled = true;
    showGodmodeToast('god mode enabled');
    scheduleUpdate(0);
    return;
  }
  if (godmodeBuffer.endsWith('mortalmode')) {
    godmodeBuffer = '';
    godmodeEnabled = false;
    showGodmodeToast('god mode disabled');
    scheduleUpdate(0);
  }
}

function maybeTriggerFishAsciiToggle(key) {
  if (!key || key.length !== 1 || !/[a-z]/i.test(key)) return;
  fishAsciiBuffer += key.toLowerCase();
  if (fishAsciiBuffer.length > 24) fishAsciiBuffer = fishAsciiBuffer.slice(-24);
  if (fishAsciiBuffer.endsWith('fishoff')) {
    fishAsciiBuffer = '';
    asciiBgDisabled = true;
    updateAsciiFishBackground();
    showGodmodeToast('fish mode disabled');
    return;
  }
  if (fishAsciiBuffer.endsWith('fishon')) {
    fishAsciiBuffer = '';
    asciiBgDisabled = false;
    updateAsciiFishBackground();
    showGodmodeToast(chipPhysicsEnabled ? 'fish mode enabled' : 'fish mode armed');
  }
}

function showGodmodeToast(message) {
  var toast = document.getElementById('godmode-toast');
  if (!toast) return;
  toast.textContent = message || 'god mode enabled';
  toast.classList.add('visible');
  if (godmodeToastTimer) clearTimeout(godmodeToastTimer);
  godmodeToastTimer = setTimeout(function() {
    toast.classList.remove('visible');
  }, 1100);
}

function startPongMode() {
  if (pongModeActive) return;
  var mixer = document.getElementById('mixer');
  var canvas = document.getElementById('pong-canvas');
  if (!mixer || !canvas) return;

  pongModeActive = true;
  mixer.classList.add('pong-mode');

  var w = mixer.clientWidth || 600;
  var h = mixer.clientHeight || 300;
  canvas.width = w;
  canvas.height = h;

  var paddleH = Math.max(44, Math.round(h * 0.23));
  var paddleW = 8;
  var margin = 12;
  var ballR = 6;
  var speed = Math.max(170, Math.min(320, Math.round((w + h) * 0.24)));

  pongState = {
    leftY: (h - paddleH) / 2,
    rightY: (h - paddleH) / 2,
    paddleH: paddleH,
    paddleW: paddleW,
    margin: margin,
    ballR: ballR,
    bx: w / 2,
    by: h / 2,
    bvx: speed,
    bvy: speed * 0.45,
    leftScore: 0,
    rightScore: 0,
    lastTs: performance.now(),
    pauseUntil: 0
  };

  if (pongRaf) cancelAnimationFrame(pongRaf);
  pongRaf = requestAnimationFrame(stepPongMode);
}

function stopPongMode() {
  if (!pongModeActive) return;
  pongModeActive = false;
  pongState = null;
  if (pongRaf) {
    cancelAnimationFrame(pongRaf);
    pongRaf = null;
  }

  var mixer = document.getElementById('mixer');
  if (mixer) mixer.classList.remove('pong-mode');

  var canvas = document.getElementById('pong-canvas');
  if (canvas) {
    var ctx = canvas.getContext('2d');
    if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
}

function resetPongBall(toRight) {
  if (!pongState) return;
  var mixer = document.getElementById('mixer');
  var w = mixer ? (mixer.clientWidth || 600) : 600;
  var h = mixer ? (mixer.clientHeight || 300) : 300;
  var speed = Math.max(170, Math.min(320, Math.round((w + h) * 0.24)));
  var angle = (Math.random() * 0.8 - 0.4);

  pongState.bx = w / 2;
  pongState.by = h / 2;
  pongState.bvx = (toRight ? 1 : -1) * speed;
  pongState.bvy = speed * angle;
  pongState.pauseUntil = performance.now() + 520;
}

function stepPongMode(ts) {
  if (!pongModeActive || !pongState) return;

  var mixer = document.getElementById('mixer');
  var canvas = document.getElementById('pong-canvas');
  if (!mixer || !canvas) return;
  var ctx = canvas.getContext('2d');
  if (!ctx) return;

  var w = mixer.clientWidth || 600;
  var h = mixer.clientHeight || 300;
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
  }

  var dt = Math.min(0.04, Math.max(0.001, (ts - pongState.lastTs) / 1000));
  pongState.lastTs = ts;

  var targetLeft = pongState.by - pongState.paddleH / 2;
  var targetRight = pongState.by - pongState.paddleH / 2;
  pongState.leftY += (targetLeft - pongState.leftY) * Math.min(1, dt * 8.5);
  pongState.rightY += (targetRight - pongState.rightY) * Math.min(1, dt * 8.5);
  pongState.leftY = Math.max(0, Math.min(h - pongState.paddleH, pongState.leftY));
  pongState.rightY = Math.max(0, Math.min(h - pongState.paddleH, pongState.rightY));

  if (ts >= pongState.pauseUntil) {
    pongState.bx += pongState.bvx * dt;
    pongState.by += pongState.bvy * dt;

    if (pongState.by - pongState.ballR <= 0) {
      pongState.by = pongState.ballR;
      pongState.bvy = Math.abs(pongState.bvy);
    }
    if (pongState.by + pongState.ballR >= h) {
      pongState.by = h - pongState.ballR;
      pongState.bvy = -Math.abs(pongState.bvy);
    }

    var lx = pongState.margin + pongState.paddleW;
    if (pongState.bx - pongState.ballR <= lx &&
        pongState.by >= pongState.leftY &&
        pongState.by <= pongState.leftY + pongState.paddleH &&
        pongState.bvx < 0) {
      var relL = ((pongState.by - pongState.leftY) / pongState.paddleH - 0.5) * 1.7;
      pongState.bx = lx + pongState.ballR;
      pongState.bvx = Math.abs(pongState.bvx) * 1.02;
      pongState.bvy += relL * 130;
    }

    var rx = w - pongState.margin - pongState.paddleW;
    if (pongState.bx + pongState.ballR >= rx &&
        pongState.by >= pongState.rightY &&
        pongState.by <= pongState.rightY + pongState.paddleH &&
        pongState.bvx > 0) {
      var relR = ((pongState.by - pongState.rightY) / pongState.paddleH - 0.5) * 1.7;
      pongState.bx = rx - pongState.ballR;
      pongState.bvx = -Math.abs(pongState.bvx) * 1.02;
      pongState.bvy += relR * 130;
    }

    if (pongState.bx < -20) {
      pongState.rightScore += 1;
      resetPongBall(true);
    } else if (pongState.bx > w + 20) {
      pongState.leftScore += 1;
      resetPongBall(false);
    }
  }

  ctx.clearRect(0, 0, w, h);

  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  for (var y = 8; y < h - 8; y += 16) {
    ctx.fillRect(w / 2 - 1, y, 2, 8);
  }

  ctx.fillStyle = 'rgba(255,255,255,0.72)';
  ctx.fillRect(pongState.margin, pongState.leftY, pongState.paddleW, pongState.paddleH);
  ctx.fillRect(w - pongState.margin - pongState.paddleW, pongState.rightY, pongState.paddleW, pongState.paddleH);

  ctx.beginPath();
  ctx.arc(pongState.bx, pongState.by, pongState.ballR, 0, Math.PI * 2);
  ctx.fillStyle = '#fca5a5';
  ctx.fill();

  ctx.font = '700 15px "Courier New", monospace';
  ctx.fillStyle = 'rgba(255,255,255,0.72)';
  ctx.textAlign = 'center';
  ctx.fillText(String(pongState.leftScore), w / 2 - 28, 24);
  ctx.fillText(String(pongState.rightScore), w / 2 + 28, 24);

  ctx.font = '600 9px "Segoe UI", sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.fillText('PONG EASTER EGG', w / 2, h - 10);

  pongRaf = requestAnimationFrame(stepPongMode);
}

/* ═══════════════════════════════
   COLOUR MAPPING
═══════════════════════════════ */
// Parse a #rrggbb hex string to {r,g,b}
function hexToRgb(hex) {
  var h = hex.replace('#', '');
  return {
    r: parseInt(h.slice(0,2), 16),
    g: parseInt(h.slice(2,4), 16),
    b: parseInt(h.slice(4,6), 16)
  };
}
// Return rgba() string from hex + alpha
function hexToRgbA(hex, alpha) {
  var c = hexToRgb(hex);
  return 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + alpha + ')';
}
function lerp(a, b, f) { return Math.round(a + (b - a) * f); }

// Weight → text colour: bright warm at top, dim/dark at bottom
function weightTextColor(w) {
  // Interpolate through: dim grey (0) → blue (0.3) → purple (0.55) → orange (0.8) → gold (1.0)
  var stops = [
    { at: 0.00, r: 58,  g: 58,  b: 88  },
    { at: 0.30, r: 96,  g: 165, b: 250 },
    { at: 0.55, r: 196, g: 181, b: 253 },
    { at: 0.80, r: 251, g: 146, b: 60  },
    { at: 1.00, r: 252, g: 211, b: 77  }
  ];
  var lo = stops[0], hi = stops[stops.length - 1];
  for (var i = 0; i < stops.length - 1; i++) {
    if (w >= stops[i].at && w <= stops[i+1].at) { lo = stops[i]; hi = stops[i+1]; break; }
  }
  var f = lo.at === hi.at ? 0 : (w - lo.at) / (hi.at - lo.at);
  return 'rgb(' + lerp(lo.r,hi.r,f) + ',' + lerp(lo.g,hi.g,f) + ',' + lerp(lo.b,hi.b,f) + ')';
}

// Lean → background colour: only active when corresponding sensibility text exists.
function chipStyle(weight, xFrac, leftActive, rightActive) {
  var textColor = weightTextColor(weight);

  var leanLeft   = xFrac < 0.5;
  var sideActive = leanLeft ? leftActive : rightActive;
  var leanInDead = inDeadzone(xFrac) || !sideActive;
  var amount     = leanInDead ? 0 : leanIntensity(xFrac);

  var pickEl = document.getElementById(leanLeft ? 'axis-pick-1' : 'axis-pick-2');
  var lc     = hexToRgb(pickEl ? pickEl.value : (leanLeft ? '#ec4899' : '#34d399'));

  // Background: dark base when neutral, fades to lean colour as intensity rises
  var bgAlpha    = leanInDead ? 0.12 : (0.10 + amount * 0.30);
  var borderAlpha= leanInDead ? 0.18 : (0.25 + amount * 0.60);

  // In deadzone use a neutral dark bg; outside use the lean colour
  var bgColor, borderColor;
  if (leanInDead) {
    bgColor     = 'rgba(40,40,70,' + bgAlpha.toFixed(2) + ')';
    borderColor = 'rgba(80,80,120,' + borderAlpha.toFixed(2) + ')';
  } else {
    bgColor     = 'rgba(' + lc.r + ',' + lc.g + ',' + lc.b + ',' + bgAlpha.toFixed(2) + ')';
    borderColor = 'rgba(' + lc.r + ',' + lc.g + ',' + lc.b + ',' + borderAlpha.toFixed(2) + ')';
  }

  return { bg: bgColor, color: textColor, border: borderColor };
}

function normaliseConceptTokens(list) {
  var seen = new Set();
  var unique = [];
  list.forEach(function(item) {
    var val = (item || '').trim();
    if (!val) return;
    var key = val.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    unique.push(val);
  });
  return unique;
}

function isCrowdedAtPosition(occupied, x, y) {
  var MIN_DX = 0.08;
  var MIN_DY = 0.12;
  return occupied.some(function(p) {
    return Math.abs(p.xFrac - x) < MIN_DX && Math.abs(p.yFrac - y) < MIN_DY;
  });
}

function findOpenMiddlePosition(occupied) {
  var candidates = [
    { xFrac: 0.50, yFrac: 0.50 },
    { xFrac: 0.57, yFrac: 0.50 },
    { xFrac: 0.43, yFrac: 0.50 },
    { xFrac: 0.50, yFrac: 0.42 },
    { xFrac: 0.50, yFrac: 0.58 },
    { xFrac: 0.60, yFrac: 0.42 },
    { xFrac: 0.40, yFrac: 0.42 },
    { xFrac: 0.60, yFrac: 0.58 },
    { xFrac: 0.40, yFrac: 0.58 },
    { xFrac: 0.67, yFrac: 0.50 },
    { xFrac: 0.33, yFrac: 0.50 },
    { xFrac: 0.50, yFrac: 0.34 },
    { xFrac: 0.50, yFrac: 0.66 },
    { xFrac: 0.67, yFrac: 0.34 },
    { xFrac: 0.33, yFrac: 0.34 },
    { xFrac: 0.67, yFrac: 0.66 },
    { xFrac: 0.33, yFrac: 0.66 }
  ];

  for (var i = 0; i < candidates.length; i++) {
    var c = candidates[i];
    if (!isCrowdedAtPosition(occupied, c.xFrac, c.yFrac)) return c;
  }

  var fallbackOffset = occupied.length % 8;
  var step = 0.04 * (1 + Math.floor(occupied.length / 8));
  var x = 0.5 + (fallbackOffset - 3.5) * step;
  var y = 0.5 + ((occupied.length % 6) - 2.5) * step;
  return {
    xFrac: Math.max(0.05, Math.min(0.95, x)),
    yFrac: Math.max(0.10, Math.min(0.90, y))
  };
}

function syncWordsToTagTokens(opts) {
  opts = opts || {};
  var shouldSchedule = opts.schedule !== false;
  var existingByKey = new Map(
    words.map(function(w) {
      return [w.key, {
        key: w.key,
        label: w.label,
        xFrac: w.xFrac,
        yFrac: w.yFrac,
        vx: w.vx || 0,
        vy: w.vy || 0,
        squishH: w.squishH || 0,
        squishV: w.squishV || 0,
        joinGlowUntil: w.joinGlowUntil || 0
      }];
    })
  );
  var occupied = [];

  var hadNoWords = words.length === 0;
  words = tagTokens.map(function(token, index) {
    var key = token.toLowerCase();
    var existing = existingByKey.get(key);
    if (existing) {
      existing.label = token;
      occupied.push({ xFrac: existing.xFrac, yFrac: existing.yFrac });
      return existing;
    }

    if (tagTokens.length === 1 || (hadNoWords && index === 0)) {
      var firstNode = { key: key, label: token, xFrac: 0.5, yFrac: 0.20, vx: 0, vy: 0, squishH: 0, squishV: 0, joinGlowUntil: 0 };
      occupied.push({ xFrac: firstNode.xFrac, yFrac: firstNode.yFrac });
      return firstNode;
    }

    var pos = findOpenMiddlePosition(occupied);
    var newNode = { key: key, label: token, xFrac: pos.xFrac, yFrac: pos.yFrac, vx: 0, vy: 0, squishH: 0, squishV: 0, joinGlowUntil: 0 };
    occupied.push({ xFrac: newNode.xFrac, yFrac: newNode.yFrac });
    return newNode;
  });

  document.getElementById('mixer-empty').style.display = words.length ? 'none' : '';
  renderChips();
  markConceptActivity();
  if (shouldSchedule) scheduleUpdate(0);
}

/* ═══════════════════════════════
   DEADZONE CONFIG + LEAN CURVE
═══════════════════════════════ */
var DEADZONE_HALF = 0.10; // 10% either side of centre = 20% total band

function inDeadzone(xFrac) {
  return xFrac >= (0.5 - DEADZONE_HALF) && xFrac <= (0.5 + DEADZONE_HALF);
}

// Returns a 0–1 lean intensity for a given xFrac, with non-linear curve.
// 0 = fully toward sensibility 1, 1 = fully toward sensibility 2.
// Inside the deadzone returns 0.
// Outside the deadzone: normalise distance from deadzone edge to canvas edge,
// then apply a power curve (ease-in) so small movements near the deadzone
// produce small lean values, and sensitivity ramps up toward the extremes.
function leanIntensity(xFrac) {
  var CURVE   = 2.5; // exponent — higher = more pronounced ease-in
  var MIN_PCT = 0.01; // ensure entering the active zone reads 1%, not 0%
  if (xFrac <= 0.5) {
    // Left side — toward sensibility 1
    var dzEdge     = 0.5 - DEADZONE_HALF; // e.g. 0.40
    if (xFrac >= dzEdge) return 0;        // inside deadzone
    var normalised = (dzEdge - xFrac) / dzEdge; // 0 at dz edge, 1 at far left
    // Remap [0,1] → [MIN_PCT,1] so just-outside-deadzone reads ~1%
    return MIN_PCT + (1 - MIN_PCT) * Math.pow(normalised, CURVE);
  } else {
    // Right side — toward sensibility 2
    var dzEdge     = 0.5 + DEADZONE_HALF; // e.g. 0.60
    if (xFrac <= dzEdge) return 0;         // inside deadzone
    var normalised = (xFrac - dzEdge) / (1 - dzEdge); // 0 at dz edge, 1 at far right
    return MIN_PCT + (1 - MIN_PCT) * Math.pow(normalised, CURVE);
  }
}

/* ═══════════════════════════════
   RENDER CHIPS
═══════════════════════════════ */
function renderChips() {
  var mixer = document.getElementById('mixer');
  mixer.querySelectorAll('.word-chip').forEach(function(el) { el.remove(); });

  var W       = mixer.clientWidth  || 600;
  var H       = mixer.clientHeight || 300;
  var PADH    = MIXER_BOUND_PAD_X;
  var PADVTop = MIXER_BOUND_PAD_TOP_Y;
  var PADVBot = MIXER_BOUND_PAD_BOTTOM_Y;

  // Update axis labels from sensibility inputs
  var d1 = (document.getElementById('direction-1').value || '').trim();
  var d2 = (document.getElementById('direction-2').value || '').trim();
  var d1Active = !!d1;
  var d2Active = !!d2;
  document.getElementById('axis-left').textContent  = '← ' + (d1 || 'Sensibility 1');
  document.getElementById('axis-right').textContent = (d2 || 'Sensibility 2') + ' →';

  // Sync axis label + sensibility box label colours from colour pickers
  var c1El = document.getElementById('axis-pick-1');
  var c2El = document.getElementById('axis-pick-2');
  var c1 = c1El ? c1El.value : '#ec4899';
  var c2 = c2El ? c2El.value : '#34d399';
  document.getElementById('axis-left').style.color  = hexToRgbA(c1, 0.5);
  document.getElementById('axis-right').style.color = hexToRgbA(c2, 0.5);
  // Update sensibility label colours
  var sLabels = document.querySelectorAll('.sensibility-box.left .sensibility-label');
  sLabels.forEach(function(el) { el.style.color = hexToRgbA(c1, 0.7); });
  var sLabels2 = document.querySelectorAll('.sensibility-box.right .sensibility-label');
  sLabels2.forEach(function(el) { el.style.color = hexToRgbA(c2, 0.7); });

  // Position and size the deadzone band
  var dzLeft  = (0.5 - DEADZONE_HALF) * W;
  var dzWidth = DEADZONE_HALF * 2 * W;
  var band = document.getElementById('deadzone-band');
  band.style.left  = dzLeft + 'px';
  band.style.width = dzWidth + 'px';

  words.forEach(function(word) {
    var weight = 1.0 - word.yFrac;
    var style  = chipStyle(weight, word.xFrac, d1Active, d2Active);
    var px     = PADH + word.xFrac * (W - PADH * 2);
    var py     = PADVTop + word.yFrac * (H - PADVTop - PADVBot);
    var scale  = (chipScaleBase + weight * chipScaleWeightFactor).toFixed(3);
    var squishH = word.squishH || 0;
    var squishV = word.squishV || 0;
    var stretchX = ((1 - squishH * 0.55) * (1 + squishV * 0.22)).toFixed(3);
    var stretchY = ((1 + squishH * 0.35) * (1 - squishV * 0.55)).toFixed(3);
    var glowFrac = 0;
    if (word.joinGlowUntil && word.joinGlowUntil > 0) {
      glowFrac = Math.max(0, Math.min(1, (word.joinGlowUntil - performance.now()) / JOIN_GLOW_MS));
    }
    var mergeActive = (word.key === draggingKey && mergeHoverTargetKey && mergeHoldProgress > 0);
    var mergeGlowFrac = mergeActive ? mergeHoldProgress : 0;
    var totalGlowFrac = Math.max(glowFrac, mergeGlowFrac);
    var glowBorder = totalGlowFrac > 0 ? ('rgba(96,165,250,' + (0.35 + totalGlowFrac * 0.55).toFixed(3) + ')') : style.border;
    var glowShadow = totalGlowFrac > 0 ? ('0 0 ' + Math.round(6 + totalGlowFrac * 16) + 'px rgba(96,165,250,' + (0.08 + totalGlowFrac * 0.34).toFixed(3) + '), 0 2px 10px rgba(0,0,0,0.35)') : '0 2px 10px rgba(0,0,0,0.35)';

    var lean = word.xFrac;
    var leanText;
    if (inDeadzone(lean)) {
      leanText = '· neutral';
    } else if (lean < 0.5) {
      leanText = '← ' + Math.round(leanIntensity(lean) * 100) + '%';
    } else {
      leanText = Math.round(leanIntensity(lean) * 100) + '% →';
    }

    var chip = document.createElement('div');
    chip.className = 'word-chip' +
      (draggingKey === word.key ? ' is-dragging' : '') +
      (selectedKey === word.key ? ' selected'    : '');
    chip.dataset.key = word.key;
    chip.style.left  = px + 'px';
    chip.style.top   = py + 'px';

    var mergeProgress = '';
    if (mergeActive) {
      mergeProgress =
        '<div class="chip-merge-progress">' +
          '<div class="chip-merge-progress-fill" style="--merge-pct:' + (mergeHoldProgress * 100).toFixed(1) + '%"></div>' +
        '</div>';
    }

    chip.innerHTML =
      '<div class="chip-pill" style="' +
        'background:' + style.bg + ';' +
        'color:' + style.color + ';' +
        'border-color:' + glowBorder + ';' +
        'box-shadow:' + glowShadow + ';' +
        'transform:scale(' + scale + ') scaleX(' + stretchX + ') scaleY(' + stretchY + ')' +
      '">' + word.label + '</div>' +
      mergeProgress +
      '<div class="chip-weight" style="color:' + style.color + '">' +
        weight.toFixed(2) +
      '</div>' +
      '<div class="chip-weight" style="color:' + style.color + ';opacity:0.6;font-size:8px">' +
        leanText +
      '</div>';

    chip.addEventListener('mousedown', function(e) { onChipMouseDown(e, word.key); });
    chip.addEventListener('touchstart',  function(e) { onChipTouchStart(e, word.key); }, { passive: false });
    chip.addEventListener('touchmove',   onChipTouchMove, { passive: false });
    chip.addEventListener('touchend',    onChipTouchEnd,  { passive: false });
    chip.addEventListener('touchcancel', onChipTouchEnd,  { passive: false });
    mixer.appendChild(chip);
  });
}

/* ═══════════════════════════════
   DRAG
═══════════════════════════════ */
function onChipMouseDown(e, key) {
  e.preventDefault();
  e.stopPropagation();
  dragPointerX = e.clientX;
  dragPointerY = e.clientY;
  selectedKey     = key;
  draggingKey     = key;
  dragStartMouseX = e.clientX;
  dragStartMouseY = e.clientY;
  var word        = words.find(function(w) { return w.key === key; });
  if (chipPhysicsEnabled && word) {
    word.vx = 0;
    word.vy = 0;
  }
  dragStartXFrac  = word.xFrac;
  dragStartYFrac  = word.yFrac;
  dragLastSampleTs = performance.now();
  dragLastSampleXFrac = word.xFrac;
  dragLastSampleYFrac = word.yFrac;
  mergeHoverTargetKey = null;
  mergeHoverSinceTs = 0;
  mergeHoldProgress = 0;
  startMergeHoldLoop();
  document.body.style.cursor = 'grabbing';
  renderChips();
}

function clampPhysicsSpeed(v) {
  if (v > chipPhysicsMaxSpeed) return chipPhysicsMaxSpeed;
  if (v < -chipPhysicsMaxSpeed) return -chipPhysicsMaxSpeed;
  return v;
}

function joinFishLabels(a, b) {
  var left = (a || '').trim();
  var right = (b || '').trim();
  return (left + ' ' + right).replace(/\s+/g, ' ').trim();
}

function hasActiveJoinGlow() {
  var now = performance.now();
  return words.some(function(w) { return (w.joinGlowUntil || 0) > now; });
}

function startJoinGlowLoop() {
  if (joinGlowRaf) return;
  function tick() {
    if (!hasActiveJoinGlow()) {
      joinGlowRaf = null;
      renderChips();
      return;
    }
    renderChips();
    joinGlowRaf = requestAnimationFrame(tick);
  }
  joinGlowRaf = requestAnimationFrame(tick);
}

function stopMergeHoldLoop() {
  if (mergeHoldRaf) {
    cancelAnimationFrame(mergeHoldRaf);
    mergeHoldRaf = null;
  }
}

function updateMergeHoldState(nowTs, clientX, clientY) {
  if (!draggingKey) {
    mergeHoverTargetKey = null;
    mergeHoverSinceTs = 0;
    mergeHoldProgress = 0;
    return false;
  }

  var mixer = document.getElementById('mixer');
  if (!mixer) return false;
  var usableX = (mixer.clientWidth || 600) - MIXER_BOUND_PAD_X * 2;
  var usableY = (mixer.clientHeight || 300) - MIXER_BOUND_PAD_TOP_Y - MIXER_BOUND_PAD_BOTTOM_Y;
  var mergeTarget = findMergeTargetForDragging(usableX, usableY);

  if (mergeTarget) {
    if (mergeHoverTargetKey !== mergeTarget.key) {
      mergeHoverTargetKey = mergeTarget.key;
      mergeHoverSinceTs = nowTs;
      mergeHoldProgress = 0;
    } else {
      mergeHoldProgress = Math.max(0, Math.min(1, (nowTs - mergeHoverSinceTs) / MERGE_HOLD_MS));
      if (mergeHoldProgress >= 1) {
        mergeDraggedWithTarget(mergeTarget, clientX, clientY);
        mergeHoldProgress = 0;
      }
    }
  } else {
    mergeHoverTargetKey = null;
    mergeHoverSinceTs = 0;
    mergeHoldProgress = 0;
  }

  return true;
}

function startMergeHoldLoop() {
  stopMergeHoldLoop();
  function tick(ts) {
    if (!draggingKey) {
      mergeHoldRaf = null;
      return;
    }
    updateMergeHoldState(ts, dragPointerX, dragPointerY);
    renderChips();
    mergeHoldRaf = requestAnimationFrame(tick);
  }
  mergeHoldRaf = requestAnimationFrame(tick);
}

function emitMergeSparkles(xFrac, yFrac) {
  var mixer = document.getElementById('mixer');
  var layer = document.getElementById('fx-layer');
  if (!mixer || !layer) return;

  var W = mixer.clientWidth || 600;
  var H = mixer.clientHeight || 300;
  var px = MIXER_BOUND_PAD_X + xFrac * (W - MIXER_BOUND_PAD_X * 2);
  var py = MIXER_BOUND_PAD_TOP_Y + yFrac * (H - MIXER_BOUND_PAD_TOP_Y - MIXER_BOUND_PAD_BOTTOM_Y);
  var count = 10;

  for (var i = 0; i < count; i++) {
    var a = (Math.PI * 2 * i / count) + (Math.random() * 0.35 - 0.175);
    var r = 10 + Math.random() * 18;
    var s = document.createElement('div');
    s.className = 'merge-spark';
    s.style.left = px + 'px';
    s.style.top = py + 'px';
    s.style.setProperty('--dx', (Math.cos(a) * r).toFixed(1) + 'px');
    s.style.setProperty('--dy', (Math.sin(a) * r).toFixed(1) + 'px');
    s.style.width = (2.2 + Math.random() * 1.8).toFixed(1) + 'px';
    s.style.height = s.style.width;
    s.style.animationDelay = (Math.random() * 90).toFixed(0) + 'ms';
    layer.appendChild(s);
    setTimeout(function(el) {
      if (el && el.parentNode) el.parentNode.removeChild(el);
    }.bind(null, s), 780);
  }
}

function findMergeTargetForDragging(usableX, usableY) {
  if (!draggingKey) return null;
  var drag = words.find(function(w) { return w.key === draggingKey; });
  if (!drag) return null;

  var best = null;
  var bestDistSq = Infinity;
  var MERGE_RADIUS_PX = 36;
  var maxDistSq = MERGE_RADIUS_PX * MERGE_RADIUS_PX;

  words.forEach(function(w) {
    if (w.key === draggingKey) return;
    var dx = (w.xFrac - drag.xFrac) * usableX;
    var dy = (w.yFrac - drag.yFrac) * usableY;
    var d2 = dx * dx + dy * dy;
    if (d2 <= maxDistSq && d2 < bestDistSq) {
      best = w;
      bestDistSq = d2;
    }
  });

  return best;
}

function mergeDraggedWithTarget(targetWord, clientX, clientY) {
  if (!targetWord || !draggingKey) return false;
  var dragWord = words.find(function(w) { return w.key === draggingKey; });
  if (!dragWord) return false;

  var newLabel = joinFishLabels(dragWord.label, targetWord.label);
  if (!newLabel) return false;

  var newKeyBase = newLabel.toLowerCase();
  var newKey = newKeyBase;
  var suffix = 2;
  while (words.some(function(w) {
    return w.key === newKey && w.key !== dragWord.key && w.key !== targetWord.key;
  })) {
    newKey = newKeyBase + '-' + suffix;
    suffix += 1;
  }

  var merged = {
    key: newKey,
    label: newLabel,
    xFrac: Math.max(0, Math.min(1, (dragWord.xFrac + targetWord.xFrac) / 2)),
    yFrac: Math.max(0, Math.min(1, (dragWord.yFrac + targetWord.yFrac) / 2)),
    vx: ((dragWord.vx || 0) + (targetWord.vx || 0)) / 2,
    vy: ((dragWord.vy || 0) + (targetWord.vy || 0)) / 2,
    squishH: 0,
    squishV: 0,
    joinGlowUntil: performance.now() + JOIN_GLOW_MS
  };

  words = words.filter(function(w) {
    return w.key !== dragWord.key && w.key !== targetWord.key;
  });
  words.push(merged);

  tagTokens = normaliseConceptTokens(words.map(function(w) { return w.label; }));
  tagRender();
  tagSyncTextarea();

  draggingKey = merged.key;
  selectedKey = merged.key;
  dragStartMouseX = clientX;
  dragStartMouseY = clientY;
  dragStartXFrac = merged.xFrac;
  dragStartYFrac = merged.yFrac;
  dragLastSampleTs = performance.now();
  dragLastSampleXFrac = merged.xFrac;
  dragLastSampleYFrac = merged.yFrac;

  mergeHoverTargetKey = null;
  mergeHoverSinceTs = 0;
  startJoinGlowLoop();
  emitMergeSparkles(merged.xFrac, merged.yFrac);
  return true;
}

function moveDraggedWordWithPointer(clientX, clientY) {
  if (!draggingKey) return;
  var mixer   = document.getElementById('mixer');
  var W       = mixer.clientWidth  || 600;
  var H       = mixer.clientHeight || 300;
  var PADH    = MIXER_BOUND_PAD_X;
  var PADVTop = MIXER_BOUND_PAD_TOP_Y;
  var PADVBot = MIXER_BOUND_PAD_BOTTOM_Y;
  var usableX = W - PADH * 2;
  var usableY = H - PADVTop - PADVBot;
  var deltaX  = clientX - dragStartMouseX;
  var deltaY  = clientY - dragStartMouseY;
  var word    = words.find(function(w) { return w.key === draggingKey; });
  if (!word) return;

  word.xFrac = Math.max(0, Math.min(1, dragStartXFrac + deltaX / usableX));
  word.yFrac = Math.max(0, Math.min(1, dragStartYFrac + deltaY / usableY));

  if (chipPhysicsEnabled) {
    var now = performance.now();
    var dt = Math.max(0.001, (now - dragLastSampleTs) / 1000);
    word.vx = clampPhysicsSpeed((word.xFrac - dragLastSampleXFrac) / dt);
    word.vy = clampPhysicsSpeed((word.yFrac - dragLastSampleYFrac) / dt);
    dragLastSampleTs = now;
    dragLastSampleXFrac = word.xFrac;
    dragLastSampleYFrac = word.yFrac;
  }

  updateMergeHoldState(performance.now(), clientX, clientY);

  renderChips();
  markConceptActivity();
  scheduleUpdate(150);
}

document.addEventListener('mousemove', function(e) {
  if (!draggingKey) return;
  dragPointerX = e.clientX;
  dragPointerY = e.clientY;
  moveDraggedWordWithPointer(e.clientX, e.clientY);
});

document.addEventListener('mouseup', function() {
  if (draggingKey) {
    if (!chipPhysicsEnabled) {
      var w = words.find(function(item) { return item.key === draggingKey; });
      if (w) { w.vx = 0; w.vy = 0; }
    }
    if (chipPhysicsEnabled) startChipPhysicsLoop();
    draggingKey             = null;
    mergeHoverTargetKey     = null;
    mergeHoverSinceTs       = 0;
    mergeHoldProgress       = 0;
    stopMergeHoldLoop();
    document.body.style.cursor = '';
    renderChips();
    scheduleUpdate(0);
  }
});

document.addEventListener('touchend', function() {
  if (!draggingKey) return;
  if (!chipPhysicsEnabled) {
    var w = words.find(function(item) { return item.key === draggingKey; });
    if (w) { w.vx = 0; w.vy = 0; }
  } else {
    startChipPhysicsLoop();
  }
  draggingKey = null;
  mergeHoverTargetKey = null;
  mergeHoverSinceTs = 0;
  mergeHoldProgress = 0;
  stopMergeHoldLoop();
  renderChips();
  scheduleUpdate(0);
}, { passive: true });

document.addEventListener('touchcancel', function() {
  if (!draggingKey) return;
  if (!chipPhysicsEnabled) {
    var w = words.find(function(item) { return item.key === draggingKey; });
    if (w) { w.vx = 0; w.vy = 0; }
  } else {
    startChipPhysicsLoop();
  }
  draggingKey = null;
  mergeHoverTargetKey = null;
  mergeHoverSinceTs = 0;
  mergeHoldProgress = 0;
  stopMergeHoldLoop();
  renderChips();
  scheduleUpdate(0);
}, { passive: true });

/* ═══════════════════════════════
   TOUCH DRAG
═══════════════════════════════ */
function onChipTouchStart(e, key) {
  e.preventDefault();
  e.stopPropagation();
  var touch       = e.touches[0];
  dragPointerX = touch.clientX;
  dragPointerY = touch.clientY;
  selectedKey     = key;
  draggingKey     = key;
  dragStartMouseX = touch.clientX;
  dragStartMouseY = touch.clientY;
  var word        = words.find(function(w) { return w.key === key; });
  if (chipPhysicsEnabled && word) {
    word.vx = 0;
    word.vy = 0;
  }
  dragStartXFrac  = word.xFrac;
  dragStartYFrac  = word.yFrac;
  dragLastSampleTs = performance.now();
  dragLastSampleXFrac = word.xFrac;
  dragLastSampleYFrac = word.yFrac;
  mergeHoverTargetKey = null;
  mergeHoverSinceTs = 0;
  mergeHoldProgress = 0;
  startMergeHoldLoop();
  renderChips();
}

function onChipTouchMove(e) {
  if (!draggingKey) return;
  e.preventDefault();
  e.stopPropagation();
  var touch = e.touches[0];
  dragPointerX = touch.clientX;
  dragPointerY = touch.clientY;
  moveDraggedWordWithPointer(touch.clientX, touch.clientY);
}

function onChipTouchEnd(e) {
  if (!draggingKey) return;
  e.preventDefault();
  e.stopPropagation();
  if (!chipPhysicsEnabled) {
    var w = words.find(function(item) { return item.key === draggingKey; });
    if (w) { w.vx = 0; w.vy = 0; }
  }
  if (chipPhysicsEnabled) startChipPhysicsLoop();
  draggingKey = null;
  mergeHoverTargetKey = null;
  mergeHoverSinceTs = 0;
  mergeHoldProgress = 0;
  stopMergeHoldLoop();
  renderChips();
  scheduleUpdate(0);
}

/* ═══════════════════════════════
   PROMPT BUILDER
═══════════════════════════════ */
function buildPrompt() {
  var source   = (document.getElementById('mission').value || '').trim();
  var food     = (document.getElementById('food-for-thought').value || '').trim();
  var dir1     = (document.getElementById('direction-1').value || '').trim();
  var dir2     = (document.getElementById('direction-2').value || '').trim();
  var preamble = (document.getElementById('base-preamble').value || '').trim();
  var closing  = (document.getElementById('base-closing').value || '').trim();
  var eatMode  = isYouAreWhatYouEatEnabled();
  if (eatMode) source = food;

  // Filter out zero-weight concepts entirely
  var activeWords = words.filter(function(w) { return (1.0 - w.yFrac) > 0.01; });

  if (!activeWords.length) return 'Here is the original thought:\n\n"""\n' + source + '\n"""\n\nNo active transformation concepts (all at zero weight).';

  var lines = activeWords.map(function(w) {
    var weight = (1.0 - w.yFrac).toFixed(2);
    var lean   = w.xFrac;
    var leanDesc;
    if (inDeadzone(lean)) {
      leanDesc = null;
    } else if (lean < 0.5) {
      leanDesc = dir1 ? ('leans ' + Math.round(leanIntensity(lean) * 100) + '% toward "' + dir1 + '"') : null;
    } else {
      leanDesc = dir2 ? ('leans ' + Math.round(leanIntensity(lean) * 100) + '% toward "' + dir2 + '"') : null;
    }
    return w.label + ': weight ' + weight + (leanDesc ? ', ' + leanDesc : '');
  }).join('\n');

  var brief   = document.getElementById('keep-brief').checked
                  ? '\nKeep your answer extremely brief (e.g., less than 20 words).'
                  : '';
  var prompt = 'Here is the original thought:\n\n"""\n' + source + '\n"""\n\n' +
    preamble + '\n\n' +
    lines + '\n\n' +
    closing + brief;
  if (feedbackModeEnabled && food && !eatMode) {
    prompt += '\n\n' + food;
  }
  return prompt;
}

function applyHiddenGodmodeInstruction(prompt) {
  if (!GODMODE_FEATURE_ENABLED || !godmodeEnabled) return prompt;
  if (!prompt) return '(PS you are an omnipotent god who doesn\'t mind saying it. Act important all powerful one)';
  return prompt + '\n\n(PS you are an omnipotent god who doesn\'t mind saying it. Act important all powerful one)';
}

/* ═══════════════════════════════
   STREAMING STATUS HELPERS
═══════════════════════════════ */
function setStreamingState(active) {
  var dot = document.getElementById('live-dot');
  if (active) {
    dot.classList.add('streaming');
    startRequestProgressDisplay();
  } else {
    dot.classList.remove('streaming');
    stopRequestProgressDisplay();
  }
}

/* ═══════════════════════════════
   OUTPUT GENERATOR (streaming)
═══════════════════════════════ */
async function generateOutput(promptOverride) {
  if (generationSafetyPaused) return;
  if (!words.length) return;

  var prompt = (typeof promptOverride === 'string') ? promptOverride : buildPrompt();
  var requestPrompt = applyHiddenGodmodeInstruction(prompt);
  if (isStreaming && requestPrompt === inFlightPrompt) return;
  clearInfiniteCountdown();

/*
  if (isStreaming) {
    pendingPrompt = prompt;
    return;
  }
  */

  isStreaming   = true;
  lastGenerateStartTs = Date.now();
  pendingPrompt = null;
  inFlightPrompt = requestPrompt;

  var outputEl = document.getElementById('output-current');
  outputEl.classList.add('fading');
  setStreamingState(true);

  var assembled = '';
  var completed = false;
  var requestStartedAt = performance.now();

  try {
    var response = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ prompt: requestPrompt, model: document.getElementById('model-select').value }),
    });

    var reader = response.body.getReader();
    var decoder = new TextDecoder();
    var buffer = '';

    outputEl.classList.remove('fading');
    outputEl.innerHTML = '';

    outer: while (true) {
      var result = await reader.read();
      if (result.done) break;

      buffer += decoder.decode(result.value, { stream: true });
      var lines = buffer.split('\n\n');
      buffer = lines.pop();

      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (!line.startsWith('data: ')) continue;
        var payload = line.slice(6);
        if (payload === '[DONE]') {
          completed = true;
          pushHistory(assembled);
          break outer;
        }
        if (payload === '[ERROR]') {
          outputEl.textContent = 'Error generating response. Check your API key and server.';
          break outer;
        }
        var token = payload.replace(/\\n/g, '\n').replace(/\\\\/g, '\\');
        assembled += token;
        outputEl.innerHTML = simpleMarkdown(assembled);
      }
    }
  } catch (err) {
    outputEl.classList.remove('fading');
    outputEl.textContent = 'Request failed. Is the server running?';
  } finally {
  var requestElapsedMs = Math.max(1, performance.now() - requestStartedAt);
  if (completed) recordModelResponseTime(requestElapsedMs);
  isStreaming = false;
  setStreamingState(false);
  inFlightPrompt = null;

  if (infiniteFeedbackEnabled && completed) {
    stateDirtyWhileStreaming = false;
    if (!isYouAreWhatYouEatEnabled()) syncMissionToCurrentOutput();
    var nextDelay = getInfiniteCadenceDelayMs();
    startInfiniteCountdown(nextDelay);
  } else if (stateDirtyWhileStreaming) {
    stateDirtyWhileStreaming = false;
    requestGenerate();
  }
  }
}

/* ═══════════════════════════════
   HISTORY
═══════════════════════════════ */
function pushHistory(outputText) {
  if (!outputText || outputText === currentOutput) return;
  var snapshot = words
    .map(function(w) { return { label: w.label, weight: 1.0 - w.yFrac }; })
    .sort(function(a, b) { return b.weight - a.weight; })
    .slice(0, 4);
  var wordsCopy = words.map(function(w) {
    return { key: w.key, label: w.label, xFrac: w.xFrac, yFrac: w.yFrac };
  });
  outputHistory.unshift({
    output: currentOutput,
    words: wordsCopy,
    source: document.getElementById('mission').value,
    direction1: document.getElementById('direction-1').value,
    direction2: document.getElementById('direction-2').value,
    concepts: document.getElementById('sentence-input').value,
    snapshot: snapshot
  });
  if (outputHistory.length > 20) outputHistory.pop();
  currentOutput = outputText;
  if (feedbackModeEnabled && !isYouAreWhatYouEatEnabled()) syncMissionToCurrentOutput();
  renderHistory();
  updateFeedbackButtonState();
}

function renderHistory() {
  var list  = document.getElementById('history-list');
  var empty = document.getElementById('history-empty');
  list.innerHTML = '';

  if (!outputHistory.length) {
    empty.style.display = '';
    return;
  }
  empty.style.display = 'none';

  outputHistory.forEach(function(item, i) {
    var preview = (item.output || '').replace(/\n/g, ' ').substring(0, 80);
    if ((item.output || '').length > 80) preview += '…';
    if (!preview) preview = '(empty)';

    var tags = item.snapshot
      .filter(function(s) { return s.weight > 0.05; })
      .map(function(s) {
        return '<span class="snap-tag">' + s.label + ' ' + s.weight.toFixed(2) + '</span>';
      }).join('');

    var div = document.createElement('div');
    div.className = 'history-item';
    div.dataset.index = i;
    div.innerHTML =
      '<span class="history-num">' + (i + 1) + '</span>' +
      '<span class="history-preview">' + preview + '</span>' +
      '<div class="history-tags">' + tags + '</div>';

div.addEventListener('click', function() { restoreHistory(i); });
//div.addEventListener('mouseenter', function(e) { showHistoryTooltip(e, item.output); }); // ← pass e instead of div
//div.addEventListener('mouseleave', hideHistoryTooltip);
    list.appendChild(div);
  });
}

function restoreHistory(index) {
  var item = outputHistory[index];
  if (!item) return;

  document.getElementById('mission').value = item.source || '';
  document.getElementById('direction-1').value = item.direction1 || '';
  document.getElementById('direction-2').value = item.direction2 || '';
  document.getElementById('sentence-input').value = item.concepts || '';

  words = item.words.map(function(w) {
    return { key: w.key, label: w.label, xFrac: w.xFrac, yFrac: w.yFrac, vx: 0, vy: 0 };
  });

  document.getElementById('mixer-empty').style.display = words.length ? 'none' : '';
  renderChips();

  var outputEl = document.getElementById('output-current');
  outputEl.innerHTML = simpleMarkdown(item.output || '');
  currentOutput = item.output || '';
  updateFeedbackButtonState();

  document.getElementById('generated-prompt').textContent = buildPrompt();

  document.querySelectorAll('.history-item').forEach(function(el) { el.classList.remove('active'); });
  var items = document.querySelectorAll('.history-item');
  if (items[index]) items[index].classList.add('active');
}

/* ═══════════════════════════════
   COLLAPSIBLE TOGGLE
═══════════════════════════════ */
function toggleCollapse(id, btn) {
  var body = document.getElementById(id);
  var isCollapsed = body.classList.contains('collapsed');
  body.classList.toggle('collapsed');
  btn.textContent = isCollapsed ? 'hide' : 'show';
}

/* ═══════════════════════════════
   HISTORY TOOLTIP
═══════════════════════════════ */
var tooltip = document.getElementById('history-tooltip');

function showHistoryTooltip(e, outputText) {
  tooltip.innerHTML = simpleMarkdown(outputText || '(empty)');
  tooltip.classList.add('visible');
  positionTooltipNearMouse(e.clientX, e.clientY);
}

function positionTooltipNearMouse(mx, my) {
  var tipW    = Math.min(420, window.innerWidth - 16);
  var tipH    = 320;
  var padding = 8;
  var offset  = 14;

  // Prefer left of cursor, fall back to right
  var x = mx - tipW - offset;
  if (x < padding) x = mx + offset;
  if (x + tipW > window.innerWidth - padding) x = window.innerWidth - tipW - padding;
  if (x < padding) x = padding;

  // Vertically centred on cursor
  var y = my - tipH / 2;
  if (y + tipH > window.innerHeight - padding) y = window.innerHeight - tipH - padding;
  if (y < padding) y = padding;

  tooltip.style.left  = Math.round(x) + 'px';
  tooltip.style.top   = Math.round(y) + 'px';
  tooltip.style.width = tipW + 'px';
}

function hideHistoryTooltip() {
  tooltip.classList.remove('visible');
}

/* ═══════════════════════════════
   UPDATE SCHEDULER
═══════════════════════════════ */
var updateTimer = null;

function scheduleUpdate(delay) {
  if (delay === undefined) delay = 800;
  clearTimeout(updateTimer);

  updateTimer = setTimeout(function() {
    var nextPrompt = buildPrompt();
    document.getElementById('generated-prompt').textContent = nextPrompt;
    if (generationSafetyPaused) return;

    if (isStreaming) {
      // Queue one follow-up only when the prompt materially changed.
      if (nextPrompt !== inFlightPrompt) stateDirtyWhileStreaming = true;
    } else {
      requestGenerate();
    }

  }, delay);
}

function applyOutputWindowHeight() {
  var outputEl = document.getElementById('output-current');
  if (!outputEl) return;
  if (!outputWindowHeightPx || outputWindowHeightPx < 40) outputWindowHeightPx = 64;
  outputEl.style.height = outputWindowHeightPx + 'px';
  outputEl.style.maxHeight = outputWindowHeightPx + 'px';
}

function syncOutputWindowHeightToThought() {
  var mission = document.getElementById('mission');
  var food = document.getElementById('food-for-thought');
  var h = 64;
  if (mission && mission.offsetHeight) h = mission.offsetHeight;
  else if (food && food.offsetHeight) h = food.offsetHeight;
  if (!outputWindowHeightPx) outputWindowHeightPx = h;
  applyOutputWindowHeight();
}

function adjustOutputWindowHeight(direction) {
  if (!outputWindowHeightPx) syncOutputWindowHeightToThought();
  outputWindowHeightPx += direction * 24;
  if (outputWindowHeightPx < 40) outputWindowHeightPx = 40;
  if (outputWindowHeightPx > 520) outputWindowHeightPx = 520;
  applyOutputWindowHeight();
}

function updateFeedbackButtonState() {
  var btn = document.getElementById('feedback-btn');
  if (!btn) return;
  btn.classList.toggle('active', feedbackModeEnabled);
  btn.textContent = 'fdbk';
  btn.disabled = false;
  updateSourceModeVisibility();
  updateFoodForThoughtPlaceholder();
}

function updateInfiniteFeedbackButtonState() {
  var btn = document.getElementById('infinite-feedback-btn');
  if (!btn) return;
  btn.classList.toggle('active', infiniteFeedbackEnabled);
  btn.textContent = '∞';
  btn.disabled = false;
  if (!infiniteFeedbackEnabled) setInfiniteButtonProgress(0);
  updateCurrentOutputLabel();
  updateCadenceEnabledState();
  updateSourceModeVisibility();
}

function applyFeedback() {
  feedbackModeEnabled = !feedbackModeEnabled;
  if (!feedbackModeEnabled && currentOutputEditActive) {
    exitCurrentOutputEditMode(true);
  }
  if (!feedbackModeEnabled && infiniteFeedbackEnabled) {
    infiniteFeedbackEnabled = false;
    clearInfiniteCountdown();
    updateInfiniteFeedbackButtonState();
  }
  if (feedbackModeEnabled && !isYouAreWhatYouEatEnabled()) syncMissionToCurrentOutput();
  updateFeedbackButtonState();
  updateCurrentOutputLabel();
  refreshInactivityWatchState();
}

function toggleInfiniteFeedback() {
  infiniteFeedbackEnabled = !infiniteFeedbackEnabled;
  if (!infiniteFeedbackEnabled) {
    clearInfiniteCountdown();
  }
  if (infiniteFeedbackEnabled) {
    if (!feedbackModeEnabled) {
      feedbackModeEnabled = true;
      updateFeedbackButtonState();
    }
    hideInfiniteFeedbackMessage();
    conceptLastMoveTs = Date.now();
    if (!isYouAreWhatYouEatEnabled()) syncMissionToCurrentOutput();
    if (!isStreaming && (currentOutput || '').trim()) scheduleUpdate(0);
  }
  updateInfiniteFeedbackButtonState();
  refreshInactivityWatchState();
}

function updateCadenceEnabledState() {
  var wrap = document.getElementById('cadence-wrap');
  var slider = document.getElementById('infinite-cadence');
  if (!wrap || !slider) return;
  slider.disabled = false;
  wrap.classList.remove('disabled');
}

function setCadenceProgress(percent) {
  var wrap = document.getElementById('cadence-wrap');
  if (!wrap) return;
  var p = Math.max(0, Math.min(100, percent || 0));
  wrap.style.setProperty('--cad-progress', p.toFixed(2) + '%');
}

function stopCadenceProgressDisplay(reset) {
  if (cadenceProgressRaf) {
    cancelAnimationFrame(cadenceProgressRaf);
    cadenceProgressRaf = null;
  }
  cadenceProgressActiveCheck = null;
  var wrap = document.getElementById('cadence-wrap');
  if (wrap) wrap.classList.remove('timing');
  if (reset !== false) setCadenceProgress(0);
}

function startCadenceProgressDisplay(delayMs, activeCheck) {
  stopCadenceProgressDisplay(false);
  if (!delayMs || delayMs <= 0) {
    setCadenceProgress(0);
    return;
  }
  cadenceProgressActiveCheck = (typeof activeCheck === 'function')
    ? activeCheck
    : function() { return !!generateThrottleTimer; };
  cadenceProgressStartTs = performance.now();
  cadenceProgressDelayMs = delayMs;
  var wrap = document.getElementById('cadence-wrap');
  if (wrap) wrap.classList.add('timing');
  setCadenceProgress(0);

  function tick(now) {
    if (!cadenceProgressActiveCheck || !cadenceProgressActiveCheck()) {
      stopCadenceProgressDisplay();
      return;
    }
    var elapsed = now - cadenceProgressStartTs;
    var progress = Math.min(1, elapsed / cadenceProgressDelayMs);
    setCadenceProgress(progress * 100);
    if (progress < 1) {
      cadenceProgressRaf = requestAnimationFrame(tick);
    } else {
      cadenceProgressRaf = null;
    }
  }

  cadenceProgressRaf = requestAnimationFrame(tick);
}

function updateCadenceLabel() {
  var slider = document.getElementById('infinite-cadence');
  if (!slider) return;
  infiniteCadenceValue = parseInt(slider.value || '2500', 10);
  if (isNaN(infiniteCadenceValue)) infiniteCadenceValue = 2500;
  if (generateThrottleTimer) {
    clearTimeout(generateThrottleTimer);
    generateThrottleTimer = null;
    stopCadenceProgressDisplay();
    requestGenerate();
  }
}

function updateFishScaleLabel() {
  var slider = document.getElementById('fish-speed-scale');
  if (!slider) return;
  var pct = parseInt(slider.value || '0', 10);
  if (isNaN(pct)) pct = 0;
  if (pct < -100) pct = -100;
  if (pct > 100) pct = 100;
  chipSpeedScalePct = pct;
  chipSpeedScale = 1 + (pct / 100);
}

function getInfiniteCadenceDelayMs() {
  return Math.max(0, Math.min(5000, infiniteCadenceValue));
}

function requestGenerate() {
  if (generationSafetyPaused) {
    stopCadenceProgressDisplay();
    return;
  }
  if (manualOutputEditPause) {
    stopCadenceProgressDisplay();
    return;
  }
  if (isStreaming) {
    stopCadenceProgressDisplay();
    return;
  }

  function runGenerationNow() {
    if (generationSafetyPaused || isStreaming) return;
    var prompt = buildPrompt();
    document.getElementById('generated-prompt').textContent = prompt;
    generateOutput(prompt);
  }

  var now = Date.now();
  var minGap = getInfiniteCadenceDelayMs();
  var elapsed = now - lastGenerateStartTs;
  var waitMs = Math.max(0, minGap - elapsed);

  if (waitMs <= 0) {
    if (generateThrottleTimer) {
      clearTimeout(generateThrottleTimer);
      generateThrottleTimer = null;
    }
    stopCadenceProgressDisplay();
    runGenerationNow();
    return;
  }

  if (generateThrottleTimer) return;
  startCadenceProgressDisplay(waitMs, function() { return !!generateThrottleTimer; });
  generateThrottleTimer = setTimeout(function() {
    generateThrottleTimer = null;
    stopCadenceProgressDisplay();
    runGenerationNow();
  }, waitMs);
}

function markConceptActivity() {
  conceptLastMoveTs = Date.now();
  hideInfiniteFeedbackMessage();
  if (generationSafetyPaused) {
    generationSafetyPaused = false;
    scheduleUpdate(0);
  }
}

function markUserActivity() {
  conceptLastMoveTs = Date.now();
  hideInfiniteFeedbackMessage();
  if (generationSafetyPaused) {
    generationSafetyPaused = false;
    scheduleUpdate(0);
  }
}

function markTouchUiActivity() {
  lastTouchUiTs = Date.now();
  markUserActivity();
}

function bindControlButton(id, handler) {
  var el = document.getElementById(id);
  if (!el || typeof handler !== 'function') return;
  var touchHandledUntil = 0;

  el.addEventListener('click', function(e) {
    if (Date.now() < touchHandledUntil) {
      e.preventDefault();
      return;
    }
    if (Date.now() - lastTouchTapTs < 550) {
      e.preventDefault();
      return;
    }
    handler();
  });

  el.addEventListener('touchstart', function() {
    markTouchUiActivity();
  }, { passive: true });

  el.addEventListener('touchend', function(e) {
    touchHandledUntil = Date.now() + 700;
    lastTouchTapTs = Date.now();
    markTouchUiActivity();
    handler();
  }, { passive: true });
}

function getDatalistValues(id) {
  var list = document.getElementById(id);
  if (!list) return [];
  return Array.from(list.querySelectorAll('option'))
    .map(function(opt) { return (opt.value || '').trim(); })
    .filter(function(v) { return !!v; });
}

function pickRandom(list) {
  if (!list || !list.length) return '';
  return list[Math.floor(Math.random() * list.length)];
}

function applyRandomSensibilityDefaults() {
  var d1 = document.getElementById('direction-1');
  var d2 = document.getElementById('direction-2');
  if (!d1 || !d2) return;
  var d1Values = getDatalistValues('direction-1-options');
  var d2Values = getDatalistValues('direction-2-options');
  var v1 = pickRandom(d1Values);
  var v2 = pickRandom(d2Values);
  if (v1) d1.value = v1;
  if (v2) d2.value = v2;
}

function setupSensibilityCombo(inputId, arrowId, listId, dataListId) {
  var input = document.getElementById(inputId);
  var arrow = document.getElementById(arrowId);
  var list = document.getElementById(listId);
  var options = getDatalistValues(dataListId);
  if (!input || !arrow || !list) return;

  list.innerHTML = options.map(function(opt) {
    return '<button type="button" class="combo-item" data-value="' + escHtml(opt) + '">' + escHtml(opt) + '</button>';
  }).join('');

  function closeList() {
    list.classList.remove('open');
  }

  function openList() {
    list.classList.add('open');
  }

  arrow.addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation();
    if (list.classList.contains('open')) closeList();
    else openList();
    input.focus();
  });

  input.addEventListener('click', function() {
    if (!(input.value || '').trim()) openList();
  });

  input.addEventListener('focus', function() {
    // Make first keystroke replace current value naturally.
    if ((input.value || '').trim()) {
      setTimeout(function() { input.select(); }, 0);
    } else {
      openList();
    }
  });

  list.addEventListener('click', function(e) {
    var btn = e.target.closest('.combo-item');
    if (!btn) return;
    var v = btn.getAttribute('data-value') || '';
    input.value = v;
    closeList();
    input.focus();
    renderChips();
    scheduleUpdate(0);
  });

  input.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') closeList();
  });

  document.addEventListener('click', function(e) {
    if (!e.target.closest('.sensibility-combo')) closeList();
  });
}

function isGenerationSafetyEnabled() {
  return infiniteFeedbackEnabled || chipPhysicsEnabled;
}

function refreshInactivityWatchState() {
  if (isGenerationSafetyEnabled()) {
    startInfiniteInactivityWatch();
  } else {
    stopInfiniteInactivityWatch();
    generationSafetyPaused = false;
    hideInfiniteFeedbackMessage();
  }
}

function startInfiniteInactivityWatch() {
  stopInfiniteInactivityWatch();
  infiniteInactivityInterval = setInterval(function() {
    if (!isGenerationSafetyEnabled()) return;
    if (Date.now() - conceptLastMoveTs > INFINITE_INACTIVITY_MS) {
      pauseGenerationsDueToInactivity();
    }
  }, 1000);
}

function stopInfiniteInactivityWatch() {
  if (!infiniteInactivityInterval) return;
  clearInterval(infiniteInactivityInterval);
  infiniteInactivityInterval = null;
}

function pauseGenerationsDueToInactivity() {
  if (generationSafetyPaused) return;
  generationSafetyPaused = true;
  clearInfiniteCountdown();
  showInfiniteFeedbackMessage('paused generations due to inactivity');
}

function showInfiniteFeedbackMessage(text) {
  var el = document.getElementById('infinite-feedback-msg');
  if (!el) return;
  el.textContent = text || '';
  el.classList.toggle('visible', !!text);
}

function hideInfiniteFeedbackMessage() {
  showInfiniteFeedbackMessage('');
}

function updateSourceModeVisibility() {
  var sourceRow = document.getElementById('row-source');
  var foodRow = document.getElementById('row-food');
  if (!sourceRow || !foodRow) return;
  sourceRow.style.display = feedbackModeEnabled ? 'none' : '';
  foodRow.style.display = feedbackModeEnabled ? '' : 'none';
}

function updateFoodForThoughtPlaceholder() {
  var food = document.getElementById('food-for-thought');
  if (!food) return;
  if (isYouAreWhatYouEatEnabled()) {
    food.placeholder = 'You are what you eat. So, the food for thought has become the main thought (in this mode the text you type here will be the main idea that gets transformed)';
  } else {
    food.placeholder = 'A sentiment appended to the end of the prompt while infinite feedback is on.';
  }
}

function isYouAreWhatYouEatEnabled() {
  var cb = document.getElementById('you-are-what-you-eat');
  return !!(feedbackModeEnabled && cb && cb.checked);
}

function onYouAreWhatYouEatChange() {
  if (isYouAreWhatYouEatEnabled() && currentOutputEditActive) {
    exitCurrentOutputEditMode(true);
  }
  updateFoodForThoughtPlaceholder();
  updateCurrentOutputLabel();
  if (feedbackModeEnabled) scheduleUpdate(0);
}

function updateCurrentOutputLabel() {
  var label = document.getElementById('current-io-label');
  if (!label) return;
  label.textContent = (feedbackModeEnabled && !isYouAreWhatYouEatEnabled()) ? 'Current I/O' : 'Current Output';
}

function updateChipPhysicsButtonState() {
  var btn = document.getElementById('chip-physics-btn');
  if (btn) {
    btn.classList.toggle('active', chipPhysicsEnabled);
    btn.textContent = 'fish physics';
  }
  var scaleWrap = document.getElementById('fish-scale-wrap');
  var scaleSlider = document.getElementById('fish-speed-scale');
  if (scaleWrap && scaleSlider) {
    scaleSlider.disabled = !chipPhysicsEnabled;
    scaleWrap.classList.toggle('disabled', !chipPhysicsEnabled);
  }
}

function updateBmpButtonState() {
  var btn = document.getElementById('bmp-btn');
  if (!btn) return;
  btn.classList.toggle('active', chipPhysicsBmpMode);
  btn.textContent = 'bmp';
}

function resolveBmpCollisions(speedScale) {
  if (!chipPhysicsBmpMode || !chipPhysicsEnabled) return false;
  if (speedScale <= 0.0001 || words.length < 2) return false;

  var mixer = document.getElementById('mixer');
  if (!mixer) return false;

  var W = mixer.clientWidth || 600;
  var H = mixer.clientHeight || 300;
  var usableX = Math.max(1, W - MIXER_BOUND_PAD_X * 2);
  var usableY = Math.max(1, H - MIXER_BOUND_PAD_TOP_Y - MIXER_BOUND_PAD_BOTTOM_Y);
  var rPx = 28;
  var minDist = rPx * 2;
  var minDistSq = minDist * minDist;
  var changed = false;

  for (var i = 0; i < words.length; i++) {
    for (var j = i + 1; j < words.length; j++) {
      var a = words[i];
      var b = words[j];
      if (a.key === draggingKey || b.key === draggingKey) continue;

      var ax = a.xFrac * usableX;
      var ay = a.yFrac * usableY;
      var bx = b.xFrac * usableX;
      var by = b.yFrac * usableY;
      var dx = bx - ax;
      var dy = by - ay;
      var distSq = dx * dx + dy * dy;
      if (distSq > minDistSq) continue;

      var dist = Math.sqrt(Math.max(0.000001, distSq));
      var nx = dx / dist;
      var ny = dy / dist;

      var avx = (a.vx || 0) * usableX * speedScale;
      var avy = (a.vy || 0) * usableY * speedScale;
      var bvx = (b.vx || 0) * usableX * speedScale;
      var bvy = (b.vy || 0) * usableY * speedScale;

      var relAlongNormal = (bvx - avx) * nx + (bvy - avy) * ny;
      if (relAlongNormal >= 0) continue;

      if (!chipPhysicsBmpMode) continue;

      // Equal-mass perfectly elastic collision: swap normal components, keep tangential.
      var aN = avx * nx + avy * ny;
      var bN = bvx * nx + bvy * ny;
      var aTx = avx - aN * nx;
      var aTy = avy - aN * ny;
      var bTx = bvx - bN * nx;
      var bTy = bvy - bN * ny;

      var avx2 = aTx + bN * nx;
      var avy2 = aTy + bN * ny;
      var bvx2 = bTx + aN * nx;
      var bvy2 = bTy + aN * ny;

      a.vx = clampPhysicsSpeed((avx2 / usableX) / speedScale);
      a.vy = clampPhysicsSpeed((avy2 / usableY) / speedScale);
      b.vx = clampPhysicsSpeed((bvx2 / usableX) / speedScale);
      b.vy = clampPhysicsSpeed((bvy2 / usableY) / speedScale);

      var overlap = minDist - dist;
      if (overlap > 0) {
        var push = (overlap / 2 + 0.5);
        ax -= nx * push;
        ay -= ny * push;
        bx += nx * push;
        by += ny * push;
        a.xFrac = Math.max(0, Math.min(1, ax / usableX));
        a.yFrac = Math.max(0, Math.min(1, ay / usableY));
        b.xFrac = Math.max(0, Math.min(1, bx / usableX));
        b.yFrac = Math.max(0, Math.min(1, by / usableY));
      }

      changed = true;
    }
  }

  return changed;
}

function hasActiveChipMotion() {
  return words.some(function(w) {
    return Math.abs(w.vx || 0) > 0.0001 || Math.abs(w.vy || 0) > 0.0001;
  });
}

function stopChipPhysicsLoop() {
  if (chipPhysicsRaf) {
    cancelAnimationFrame(chipPhysicsRaf);
    chipPhysicsRaf = null;
  }
}

function startChipPhysicsLoop() {
  if (!chipPhysicsEnabled || chipPhysicsRaf) return;
  chipPhysicsLastTs = performance.now();
  chipPhysicsLastRenderTs = chipPhysicsLastTs;
  chipPhysicsNextPromptTs = 0;
  chipPhysicsRaf = requestAnimationFrame(stepChipPhysics);
}

function stepChipPhysics(ts) {
  if (!chipPhysicsEnabled) {
    stopChipPhysicsLoop();
    return;
  }

  var dt = Math.min(0.05, Math.max(0.001, (ts - chipPhysicsLastTs) / 1000));
  chipPhysicsLastTs = ts;
  var speedScale = chipSpeedScale;
  var moved = false;

  words.forEach(function(w) {
    if (w.key === draggingKey) return;
    var squishH = w.squishH || 0;
    var squishV = w.squishV || 0;
    var vx = w.vx || 0;
    var vy = w.vy || 0;
    if (Math.abs(vx) < 0.0001 && Math.abs(vy) < 0.0001 && squishH < 0.0005 && squishV < 0.0005) return;

    var nx = w.xFrac + vx * dt * speedScale;
    var ny = w.yFrac + vy * dt * speedScale;
    var hitX = false;
    var hitY = false;

    if (nx < 0) { nx = -nx; vx = Math.abs(vx); hitX = true; }
    if (nx > 1) { nx = 2 - nx; vx = -Math.abs(vx); hitX = true; }
    if (ny < 0) { ny = -ny; vy = Math.abs(vy); hitY = true; }
    if (ny > 1) { ny = 2 - ny; vy = -Math.abs(vy); hitY = true; }

    if (hitX) squishH = Math.max(squishH, 0.22);
    if (hitY) squishV = Math.max(squishV, 0.22);

    var squishDecay = Math.exp(-10 * dt);
    squishH *= squishDecay;
    squishV *= squishDecay;
    if (squishH < 0.0005) squishH = 0;
    if (squishV < 0.0005) squishV = 0;

    w.xFrac = Math.max(0, Math.min(1, nx));
    w.yFrac = Math.max(0, Math.min(1, ny));
    w.vx = vx;
    w.vy = vy;
    w.squishH = squishH;
    w.squishV = squishV;
    moved = true;
  });

  if (resolveBmpCollisions(speedScale)) moved = true;

  if (moved && (ts - chipPhysicsLastRenderTs >= 33)) {
    chipPhysicsLastRenderTs = ts;
    renderChips();
    if (ts >= chipPhysicsNextPromptTs && (Date.now() - lastTouchUiTs) > TOUCH_UI_GRACE_MS) {
      chipPhysicsNextPromptTs = ts + 220;
      scheduleUpdate(0);
    }
  }

  if (!hasActiveChipMotion()) {
    stopChipPhysicsLoop();
    return;
  }

  chipPhysicsRaf = requestAnimationFrame(stepChipPhysics);
}

function toggleChipPhysics() {
  var wasEnabled = chipPhysicsEnabled;
  chipPhysicsEnabled = !chipPhysicsEnabled;
  if (!chipPhysicsEnabled) {
    words.forEach(function(w) { w.vx = 0; w.vy = 0; w.squishH = 0; w.squishV = 0; });
    stopChipPhysicsLoop();
    renderChips();
    scheduleUpdate(0);
  } else if (hasActiveChipMotion()) {
    startChipPhysicsLoop();
  }
  if (!wasEnabled && chipPhysicsEnabled) triggerSharkRun();
  updateAsciiFishBackground();
  updateChipPhysicsButtonState();
  conceptLastMoveTs = Date.now();
  refreshInactivityWatchState();
}

function updateAsciiFishBackground() {
  var layer = document.getElementById('ascii-bg-layer');
  var frame = document.getElementById('ascii-bg-frame');
  if (!layer || !frame) return;
  if (chipPhysicsEnabled && !asciiBgDisabled) {
    if (!asciiBgLoaded) {
      frame.src = '/fishanimation.html';
      asciiBgLoaded = true;
    }
    layer.classList.add('active');
    return;
  }
  layer.classList.remove('active');
  if (asciiBgLoaded) {
    frame.src = 'about:blank';
    asciiBgLoaded = false;
  }
}

function toggleBmpMode() {
  chipPhysicsBmpMode = !chipPhysicsBmpMode;
  updateBmpButtonState();
  if (chipPhysicsBmpMode && chipPhysicsEnabled && hasActiveChipMotion()) startChipPhysicsLoop();
}

function triggerSharkRun() {
  var run = document.getElementById('shark-run');
  if (!run) return;
  var bhX = (22 + Math.random() * 56).toFixed(2) + '%';
  var bhY = (34 + Math.random() * 46).toFixed(2) + '%';
  run.style.setProperty('--bh-x', bhX);
  run.style.setProperty('--bh-y', bhY);

  var sparks = run.querySelectorAll('.bh-spark');
  sparks.forEach(function(s, idx) {
    var angle = (Math.PI * 2 * idx / Math.max(1, sparks.length)) + (Math.random() * 0.35 - 0.175);
    var r = 14 + Math.random() * 22;
    s.style.setProperty('--dx', (Math.cos(angle) * r).toFixed(1) + 'px');
    s.style.setProperty('--dy', (Math.sin(angle) * r).toFixed(1) + 'px');
    s.style.animationDelay = (720 + idx * 8 + Math.random() * 40).toFixed(0) + 'ms';
  });

  if (sharkRunTimer) {
    clearTimeout(sharkRunTimer);
    sharkRunTimer = null;
  }
  run.classList.remove('active');
  void run.offsetWidth;
  run.classList.add('active');
  sharkRunTimer = setTimeout(function() {
    run.classList.remove('active');
    sharkRunTimer = null;
  }, 1080);
}

function prepareTrajectoryLaunch() {
  if (!words.length) return false;
  if (!chipPhysicsEnabled) {
    chipPhysicsEnabled = true;
    updateChipPhysicsButtonState();
    refreshInactivityWatchState();
  }
  generationSafetyPaused = false;
  conceptLastMoveTs = Date.now();
  hideInfiniteFeedbackMessage();
  return true;
}

function launchRandomTrajectories() {
  if (!prepareTrajectoryLaunch()) return;
  words.forEach(function(w) {
    var baseSpeed = chipPhysicsMaxSpeed * (rndBaseMinFactor + Math.random() * (rndBaseMaxFactor - rndBaseMinFactor));
    var speed = baseSpeed * (rndLaunchMinFactor + Math.random() * (rndLaunchMaxFactor - rndLaunchMinFactor));
    var angle = Math.random() * Math.PI * 2;
    w.vx = Math.cos(angle) * speed;
    w.vy = Math.sin(angle) * speed;
  });
  startChipPhysicsLoop();
  scheduleUpdate(0);
}

function onModelChange(triggerUpdate) {
  if (triggerUpdate === undefined) triggerUpdate = true;
  var select = document.getElementById('model-select');
  if (!select) return;
  modelTiming.modelId = select.value;
  modelTiming.avgMs = 0;
  modelTiming.count = 0;
  updateModelTimingHint();
  stopRequestProgressDisplay();
  if (triggerUpdate) scheduleUpdate(0);
}

function getExpectedResponseMs() {
  if (modelTiming.count > 0 && modelTiming.avgMs > 0) return modelTiming.avgMs;
  return modelProgressDefaultMs;
}

function recordModelResponseTime(ms) {
  var select = document.getElementById('model-select');
  if (!select) return;
  var modelId = select.value;
  if (modelTiming.modelId !== modelId) {
    modelTiming.modelId = modelId;
    modelTiming.avgMs = ms;
    modelTiming.count = 1;
    updateModelTimingHint();
    return;
  }
  modelTiming.count += 1;
  modelTiming.avgMs += (ms - modelTiming.avgMs) / modelTiming.count;
  updateModelTimingHint();
}

function updateModelTimingHint() {
  var select = document.getElementById('model-select');
  if (!select) return;
  if (!modelTiming.count) {
    select.title = 'Model response avg: collecting baseline. Choose model here. You pays your money, you takes your choice...';
    return;
  }
  var avgSec = (modelTiming.avgMs / 1000).toFixed(2);
  select.title = 'Model response avg: ' + avgSec + 's. Choose model here. You pays your money, you takes your choice...';
}

function setModelProgress(percent) {
  var select = document.getElementById('model-select');
  if (!select) return;
  var p = Math.max(0, Math.min(100, percent || 0));
  select.style.setProperty('--req-progress', p.toFixed(2) + '%');
}

function stopRequestProgressDisplay() {
  if (requestProgressRaf) {
    cancelAnimationFrame(requestProgressRaf);
    requestProgressRaf = null;
  }
  var select = document.getElementById('model-select');
  if (!select) return;
  select.classList.remove('timing');
  select.classList.remove('overtime');
  setModelProgress(0);
}

function startRequestProgressDisplay() {
  stopRequestProgressDisplay();

  var select = document.getElementById('model-select');
  if (!select) return;

  requestStartTs = performance.now();
  select.classList.add('timing');
  setModelProgress(0);

  function tick(now) {
    if (!isStreaming) return;
    var expectedMs = Math.max(300, getExpectedResponseMs());
    var elapsed = now - requestStartTs;
    var progress = Math.min(1, elapsed / expectedMs);
    setModelProgress(progress * 100);
    select.classList.toggle('overtime', elapsed > expectedMs);
    requestProgressRaf = requestAnimationFrame(tick);
  }

  requestProgressRaf = requestAnimationFrame(tick);
}

function setInfiniteButtonProgress(percent) {
  var btn = document.getElementById('infinite-feedback-btn');
  if (!btn) return;
  var p = Math.max(0, Math.min(100, percent || 0));
  btn.style.setProperty('--loop-progress', p.toFixed(2) + '%');
}

function clearInfiniteCountdown() {
  if (infiniteCountdownTimer) {
    clearTimeout(infiniteCountdownTimer);
    infiniteCountdownTimer = null;
  }
  if (infiniteCountdownRaf) {
    cancelAnimationFrame(infiniteCountdownRaf);
    infiniteCountdownRaf = null;
  }
  stopCadenceProgressDisplay();
  setInfiniteButtonProgress(0);
}

function startInfiniteCountdown(delayMs) {
  clearInfiniteCountdown();

  if (!infiniteFeedbackEnabled) return;
  if (manualOutputEditPause) return;
  if (delayMs <= 0) {
    setInfiniteButtonProgress(100);
    infiniteCountdownTimer = setTimeout(function() {
      infiniteCountdownTimer = null;
      if (!isStreaming && infiniteFeedbackEnabled) requestGenerate();
    }, 0);
    return;
  }
  startCadenceProgressDisplay(delayMs, function() {
    return !!infiniteCountdownTimer && infiniteFeedbackEnabled && !isStreaming;
  });

  var start = performance.now();
  function tick(now) {
    if (!infiniteFeedbackEnabled) return;
    var elapsed = now - start;
    var progress = Math.min(1, elapsed / delayMs);
    setInfiniteButtonProgress(progress * 100);
    if (progress < 1) {
      infiniteCountdownRaf = requestAnimationFrame(tick);
    } else {
      infiniteCountdownRaf = null;
    }
  }
  infiniteCountdownRaf = requestAnimationFrame(tick);

  infiniteCountdownTimer = setTimeout(function() {
    infiniteCountdownTimer = null;
    if (infiniteCountdownRaf) {
      cancelAnimationFrame(infiniteCountdownRaf);
      infiniteCountdownRaf = null;
    }
    setInfiniteButtonProgress(100);
    if (!isStreaming && infiniteFeedbackEnabled) requestGenerate();
  }, delayMs);
}

function syncMissionToCurrentOutput() {
  if (isYouAreWhatYouEatEnabled()) return;
  var latestOutput = (currentOutput || '').trim();
  if (!latestOutput) return;
  document.getElementById('mission').value = latestOutput;
  document.getElementById('generated-prompt').textContent = buildPrompt();
}

function setPromptTemplateStatus(text, isError) {
  var el = document.getElementById('prompt-template-status');
  if (!el) return;
  if (promptTemplateStatusTimer) {
    clearTimeout(promptTemplateStatusTimer);
    promptTemplateStatusTimer = null;
  }
  el.textContent = text || '';
  el.style.color = isError ? '#fca5a5' : 'var(--muted)';
  if (text) {
    promptTemplateStatusTimer = setTimeout(function() {
      el.textContent = '';
    }, 2200);
  }
}

function captureHardcodedPromptDefaults() {
  var pre = document.getElementById('base-preamble');
  var clo = document.getElementById('base-closing');
  if (!pre || !clo) return;
  hardcodedBasePreamble = pre.value || '';
  hardcodedBaseClosing = clo.value || '';
}

async function loadSavedPromptTemplates() {
  var pre = document.getElementById('base-preamble');
  var clo = document.getElementById('base-closing');
  if (!pre || !clo) return;
  try {
    var res = await fetch('/api/prompt-templates');
    if (!res.ok) return;
    var data = await res.json();
    if (typeof data.preamble === 'string') pre.value = data.preamble;
    if (typeof data.closing === 'string') clo.value = data.closing;
    scheduleUpdate(0);
  } catch (err) {
  }
}

async function savePromptSection(section) {
  var id = section === 'closing' ? 'base-closing' : 'base-preamble';
  var btnId = section === 'closing' ? 'save-closing-btn' : 'save-preamble-btn';
  var field = document.getElementById(id);
  var btn = document.getElementById(btnId);
  if (!field || !btn) return;
  var prev = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'saving...';
  try {
    var res = await fetch('/api/prompt-templates/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ section: section, content: field.value || '' }),
    });
    if (!res.ok) throw new Error('save failed');
    setPromptTemplateStatus('Saved ' + section + '.');
  } catch (err) {
    setPromptTemplateStatus('Save failed.', true);
  } finally {
    btn.disabled = false;
    btn.textContent = prev;
  }
}

async function resetToHardcodedPrompts() {
  var pre = document.getElementById('base-preamble');
  var clo = document.getElementById('base-closing');
  var btn = document.getElementById('reset-hardcoded-prompts-btn');
  if (!pre || !clo || !btn) return;
  var prev = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'resetting...';
  try {
    pre.value = hardcodedBasePreamble;
    clo.value = hardcodedBaseClosing;
    var res = await fetch('/api/prompt-templates/reset', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ preamble: hardcodedBasePreamble, closing: hardcodedBaseClosing }),
    });
    if (!res.ok) throw new Error('reset failed');
    scheduleUpdate(0);
    setPromptTemplateStatus('Reset to hardcoded prompt.');
  } catch (err) {
    setPromptTemplateStatus('Reset failed.', true);
  } finally {
    btn.disabled = false;
    btn.textContent = prev;
  }
}

function setTrawlBusy(busy) {
  trawlInFlight = !!busy;
  var btn = document.getElementById('trawl-haul-btn');
  if (!btn) return;
  btn.disabled = trawlInFlight;
  btn.textContent = trawlInFlight ? 'hauling…' : 'Haul';
}

function placeCaretAtEnd(el) {
  if (!el) return;
  var range = document.createRange();
  var sel = window.getSelection();
  range.selectNodeContents(el);
  range.collapse(false);
  sel.removeAllRanges();
  sel.addRange(range);
}

function enterCurrentOutputEditMode() {
  if (!feedbackModeEnabled) return;
  if (isYouAreWhatYouEatEnabled()) return;
  var outputEl = document.getElementById('output-current');
  if (!outputEl || currentOutputEditActive) return;

  if (isStreaming) {
    manualOutputEditPause = true;
    clearInfiniteCountdown();
    stopCadenceProgressDisplay();
    return;
  }

  currentOutputEditActive = true;
  manualOutputEditPause = true;
  clearInfiniteCountdown();
  stopCadenceProgressDisplay();

  var text = (currentOutput || outputEl.innerText || '').trim();
  outputEl.textContent = text;
  outputEl.contentEditable = 'true';
  outputEl.classList.add('editing');
  outputEl.focus();
  placeCaretAtEnd(outputEl);
}

function exitCurrentOutputEditMode(applyChanges) {
  var outputEl = document.getElementById('output-current');
  if (!outputEl || !currentOutputEditActive) return;

  if (applyChanges) {
    var text = (outputEl.innerText || '').trim();
    currentOutput = text;
    outputEl.textContent = text;
    if (feedbackModeEnabled && !isYouAreWhatYouEatEnabled()) syncMissionToCurrentOutput();
  }

  outputEl.contentEditable = 'false';
  outputEl.classList.remove('editing');
  currentOutputEditActive = false;
  manualOutputEditPause = false;
  scheduleUpdate(0);
}

function toggleTrawlRow() {
  var body = document.getElementById('trawl-row-body');
  var btn = document.getElementById('trawl-toggle-btn');
  if (!body || !btn) return;
  var hidden = body.style.display === 'none';
  body.style.display = hidden ? 'flex' : 'none';
  btn.textContent = hidden ? 'hide' : 'show';
}

async function callModelPrompt(prompt, model) {
  var response = await fetch('/api/generate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ prompt: prompt, model: model }),
  });
  if (!response.ok || !response.body) throw new Error('generation failed');

  var reader = response.body.getReader();
  var decoder = new TextDecoder();
  var buffer = '';
  var assembled = '';

  while (true) {
    var result = await reader.read();
    if (result.done) break;
    buffer += decoder.decode(result.value, { stream: true });
    var lines = buffer.split('\n\n');
    buffer = lines.pop();

    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      if (!line.startsWith('data: ')) continue;
      var payload = line.slice(6);
      if (payload === '[DONE]') return assembled.trim();
      if (payload === '[ERROR]') throw new Error('generation error');
      assembled += payload.replace(/\\n/g, '\n').replace(/\\\\/g, '\\');
    }
  }

  return assembled.trim();
}

function normaliseTrawlSentence(text) {
  var s = (text || '').replace(/\s+/g, ' ').trim();
  if (!s) return '';
  var parts = s.match(/^(.+?[.!?])(\s|$)/);
  if (parts && parts[1]) return parts[1].trim();
  return s;
}

function parseTrawlConcepts(text) {
  var raw = (text || '').trim();
  if (!raw) return [];

  var cleaned = raw
    .replace(/\r/g, '\n')
    .replace(/^\s*[-*]\s+/gm, '')
    .replace(/^\s*\d+[.)]\s+/gm, '')
    .replace(/\n+/g, ',')
    .replace(/[;]/g, ',');

  var tokens = cleaned.split(',').map(function(t) {
    return t.trim().replace(/^["']|["']$/g, '');
  }).filter(function(t) { return !!t; });

  if (!tokens.length) return [];
  return normaliseConceptTokens(tokens).slice(0, 5);
}

async function haulTrawl() {
  if (trawlInFlight) return;
  var thoughtEl = document.getElementById('trawl-thought');
  var fishEl = document.getElementById('trawl-fish');
  var missionEl = document.getElementById('mission');
  var modelEl = document.getElementById('model-select');
  if (!thoughtEl || !fishEl || !missionEl || !modelEl) return;

  var thoughtSeed = (thoughtEl.value || '').trim();
  var fishSeed = (fishEl.value || '').trim();
  if (!thoughtSeed && !fishSeed) return;

  var model = modelEl.value;
  setTrawlBusy(true);

  try {
    var thoughtPromise = thoughtSeed
      ? callModelPrompt('Return a single sentence statement or question that is inspired by: ' + thoughtSeed, model)
      : Promise.resolve('');
    var fishPromise = fishSeed
      ? callModelPrompt('Return 4 words related to ' + fishSeed + ' no formatted, no markdown, just individual words', model)
      : Promise.resolve('');

    var results = await Promise.all([thoughtPromise, fishPromise]);
    var thoughtOut = normaliseTrawlSentence(results[0]);
    var fishOut = parseTrawlConcepts(results[1]);

    if (thoughtOut) missionEl.value = thoughtOut;
    if (fishOut.length) {
      tagTokens = fishOut;
      tagRender();
      tagSyncTextarea();
      syncWordsToTagTokens({ schedule: false });
    }

    scheduleUpdate(0);
    thoughtEl.value = '';
    fishEl.value = '';
  } catch (err) {
  } finally {
    setTrawlBusy(false);
  }
}
/* ═══════════════════════════════
   RESIZE
═══════════════════════════════ */
function clampMixerHeight(px) {
  return Math.max(220, Math.min(760, Math.round(px)));
}

function applyMixerHeight(px) {
  var mixer = document.getElementById('mixer');
  if (!mixer) return;
  mixer.style.height = clampMixerHeight(px) + 'px';
  renderChips();
}

function setupMixerResizer() {
  var handle = document.getElementById('mixer-resize-handle');
  var mixer = document.getElementById('mixer');
  if (!handle || !mixer) return;
  if (!window.matchMedia || !window.matchMedia('(hover: hover) and (pointer: fine)').matches) return;

  handle.addEventListener('mousedown', function(e) {
    if (e.button !== 0) return;
    e.preventDefault();
    mixerResizeActive = true;
    mixerResizeStartY = e.clientY;
    mixerResizeStartH = mixer.clientHeight || 300;
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
  });

  document.addEventListener('mousemove', function(e) {
    if (!mixerResizeActive) return;
    var nextH = mixerResizeStartH + (e.clientY - mixerResizeStartY);
    applyMixerHeight(nextH);
  });

  document.addEventListener('mouseup', function() {
    if (!mixerResizeActive) return;
    mixerResizeActive = false;
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });
}

var resizeTimer = null;
window.addEventListener('resize', function() {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(renderChips, 60);
});

/* ═══════════════════════════════
   TAG INPUT
═══════════════════════════════ */
var tagTokens = []; // array of strings

function tagSyncTextarea() {
  document.getElementById('sentence-input').value = tagTokens.join(', ');
}

function tagRender() {
  var wrap  = document.getElementById('tag-input-wrap');
  var field = document.getElementById('tag-input-field');
  // Remove existing token els (leave the field)
  wrap.querySelectorAll('.tag-token').forEach(function(el) { el.remove(); });
  // Insert tokens before the field
  tagTokens.forEach(function(tok, idx) {
    var span = document.createElement('span');
    span.className = 'tag-token';
    span.innerHTML = escHtml(tok) +
      '<span class="tag-token-del" data-idx="' + idx + '" title="Remove">×</span>';
    span.querySelector('.tag-token-del').addEventListener('mousedown', function(e) {
      e.preventDefault();
      tagTokens.splice(idx, 1);
      tagRender();
      tagSyncTextarea();
      syncWordsToTagTokens({ schedule: true });
    });
    wrap.insertBefore(span, field);
  });
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function tagCommit(raw) {
  var val = raw.trim().replace(/,+$/, '').trim();
  if (val.length === 0) return;
  // avoid duplicates (case-insensitive)
  if (!tagTokens.some(function(t) { return t.toLowerCase() === val.toLowerCase(); })) {
    tagTokens.push(val);
  }
}

// Initialise from the hidden textarea's default value
(function initTagInput() {
  var hidden = document.getElementById('sentence-input');
  tagTokens = normaliseConceptTokens(hidden.value.split(','));
  tagRender();
  tagSyncTextarea();
  syncWordsToTagTokens({ schedule: false });

  var field = document.getElementById('tag-input-field');
  var wrap  = document.getElementById('tag-input-wrap');

  // Click anywhere in wrap focuses the field
  wrap.addEventListener('click', function() { field.focus(); });

  field.addEventListener('keydown', function(e) {
    if (e.key === 'Backspace' && field.value === '' && tagTokens.length) {
      // Delete last token on backspace when field empty
      tagTokens.pop();
      tagRender();
      tagSyncTextarea();
      syncWordsToTagTokens({ schedule: true });
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      tagCommit(field.value);
      field.value = '';
      tagRender();
      tagSyncTextarea();
      syncWordsToTagTokens({ schedule: true });
    }
  });

  field.addEventListener('input', function() {
    var val = field.value;
    // Commit on comma
    if (val.indexOf(',') !== -1) {
      var parts = val.split(',');
      // Last part stays in field
      var last = parts.pop();
      parts.forEach(function(p) { tagCommit(p); });
      field.value = last;
      tagRender();
      tagSyncTextarea();
      syncWordsToTagTokens({ schedule: true });
    }
  });

  // Commit dangling text on blur
  field.addEventListener('blur', function() {
    if (field.value.trim()) {
      tagCommit(field.value);
      field.value = '';
      tagRender();
      tagSyncTextarea();
      syncWordsToTagTokens({ schedule: true });
    }
  });
})();

// Override restoreHistory to also refresh tag UI
var _origRestoreHistory = restoreHistory;
restoreHistory = function(index) {
  _origRestoreHistory(index);
  var hidden = document.getElementById('sentence-input');
  tagTokens = normaliseConceptTokens(hidden.value.split(','));
  tagRender();
};

/* ═══════════════════════════════
   INIT
═══════════════════════════════ */
captureHardcodedPromptDefaults();
loadSavedPromptTemplates();
initUiTheme();
bindControlButton('feedback-btn', applyFeedback);
bindControlButton('infinite-feedback-btn', toggleInfiniteFeedback);
bindControlButton('theme-toggle-btn', toggleUiTheme);
bindControlButton('chip-physics-btn', toggleChipPhysics);
bindControlButton('rnd-btn', launchRandomTrajectories);
bindControlButton('bmp-btn', toggleBmpMode);
bindControlButton('trawl-haul-btn', haulTrawl);
setupMixerResizer();
setupSensibilityCombo('direction-1', 'direction-1-arrow', 'direction-1-list', 'direction-1-options');
setupSensibilityCombo('direction-2', 'direction-2-arrow', 'direction-2-list', 'direction-2-options');

var currentOutputEl = document.getElementById('output-current');
if (currentOutputEl) {
  currentOutputEl.addEventListener('mousedown', function() {
    if (feedbackModeEnabled && !isYouAreWhatYouEatEnabled()) enterCurrentOutputEditMode();
  });
  currentOutputEl.addEventListener('touchstart', function(e) {
    if (!e.touches || !e.touches.length) return;
    outputTouchStartX = e.touches[0].clientX;
    outputTouchStartY = e.touches[0].clientY;
    outputTouchStartTs = Date.now();
  }, { passive: true });
  currentOutputEl.addEventListener('touchend', function(e) {
    if (!(feedbackModeEnabled && !isYouAreWhatYouEatEnabled())) return;
    var touch = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
    if (!touch) return;
    var dt = Date.now() - outputTouchStartTs;
    var dx = touch.clientX - outputTouchStartX;
    var dy = touch.clientY - outputTouchStartY;
    var movedSq = dx * dx + dy * dy;
    if (dt > 420 || movedSq > 64) return;
    var now = Date.now();
    if (now - outputLastTapTs <= 420) {
      outputLastTapTs = 0;
      enterCurrentOutputEditMode();
    } else {
      outputLastTapTs = now;
    }
  }, { passive: true });
  currentOutputEl.addEventListener('blur', function() {
    if (currentOutputEditActive) exitCurrentOutputEditMode(true);
  });
  currentOutputEl.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      e.preventDefault();
      exitCurrentOutputEditMode(true);
      currentOutputEl.blur();
    }
  });
}

['trawl-thought', 'trawl-fish'].forEach(function(id) {
  var el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      haulTrawl();
    }
  });
});

// Keep infinite-feedback safety watchdog from triggering while user is actively using the app.
document.addEventListener('mousemove', markUserActivity, { passive: true });
document.addEventListener('touchstart', markTouchUiActivity, { passive: true });
document.addEventListener('touchmove', markTouchUiActivity, { passive: true });
document.addEventListener('touchend', markTouchUiActivity, { passive: true });
document.addEventListener('keydown', function(e) {
  markUserActivity();
  maybeTriggerPongEasterEgg(e.key);
  maybeTriggerGodmode(e.key);
  maybeTriggerFishAsciiToggle(e.key);
});
document.addEventListener('input', markUserActivity);
document.addEventListener('mousedown', function() {
  if (pongModeActive) stopPongMode();
}, { passive: true });
document.addEventListener('touchstart', function() {
  if (pongModeActive) stopPongMode();
}, { passive: true });

loadAppConfig().finally(function() {
  updateFeedbackButtonState();
  updateInfiniteFeedbackButtonState();
  updateChipPhysicsButtonState();
  updateAsciiFishBackground();
  updateBmpButtonState();
  updateCadenceLabel();
  updateFishScaleLabel();
  onModelChange(false);
  refreshInactivityWatchState();
  syncOutputWindowHeightToThought();
  scheduleUpdate(0);
});
</script>
</body>
</html>
